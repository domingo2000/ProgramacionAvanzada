

# Tarea 02: DCCumbia

## Consideraciones generales 

Por lo general la tarea hace casi todo lo que se pide en el enunciado y corre fluidamente, el funcionamiento general es a través de las ventanas de inicio, ranking, ventana de juego y de resumen, las cuales son conformadas por dos instancias, una de frontend, perteneciente a la carpeta ``frontend`` y otra de backend perteneciente a la carpeta ``backend``. La unica ventana que no está hecha con layouts es la ventana de juego, por lo que ojalá no modifiquen el tamaño de esta ventana para no afectar el buen desplegamiento de la interfaz. El juego corre fluidamente, pero en caso de que este valla un poco lento se puede ajustar la ``TASA_DE_REFRESCO``, parametro que indica a la mayoría del programa cada cuanto actualizar los elementos graficos como las flechas. Este esta en un valor de 0.01 lo cual hace que se vea muy fluido el movimiento de las flechas, pero podría hacer un poco lento el juego en computadores con menos recursos (testié el juego en dos PC con 3.5ghz y 8 de RAM, pero en un notebook de 2.6 Ghz y 4 de RAM habia que subir el parametro a 0.02 - 0.05 para que funcione bien afectando un poco la fluidez de la cauida de las flechas pero haciendo mas llevadera la carga del programa), por lo que dependiendo el computador del corrector puede ajustar dicho parámetro. Además hay un par de consideraciones que nombrare en cada item que es bueno que tenga en cuenta porque hay un par de "bugs" que no logre corregir pero que no afectan gravemente al programa. Por último, todas las interfaces se hicieron en designer, por lo tanto se debe copiar y pegar la carpeta de sprites y songs en la misma carpeta T02 para que las interfaces carguen las imagenes (Pues designer guarda las rutas de la misma forma que como fueron introducidas en el programa), en caso de no cargar las imagenes en las interfaces (Que no debería pasar, puesto que lo probe en otros PC haciendo git pull), por favor habra las interfaces y ponga las imagenes en los lugares respectivos (estas son casi iguales a las que se mostraban en el enunciado). 

P.D.: Al cerrar la ventana de juego con el boton salir hay que esperar unos dos segundos antes de volver a comenzar un juego nuevo, puesto que de lo contrario se cierra la ventana de juego inmediatamente (luego  explicaré el porque).


### Cosas implementadas y no implementadas :white_check_mark: :x:

* :white_check_mark: Ventana de Incio<sub>1</sub>: Hecha completa.
	* :white_check_mark: Visualización<sub>1.1</sub>:  La ventana de inicio esta hecha en designer usando Layouts por lo que no deberían superponerse los elementos
	* :white_check_mark: Funcionamiento<sub>1.2</sub>: La ventana revisa si el nombre es alfanumérico enviando la informacion del usuario al backend de la ventana y luego si es correcto envia las señales respectivas para que se cierre la ventana de juego y se abra un juego nuevo con una instancia de ``VentanaJuego``   que corresponde al front end del juego. En caso de ser incorrecto se envía una alerta. Si presiona el botón de ranking abre la ventana de ranking y muestra los mejores puntajes.
* :white_check_mark: Ventana Ranking<sub>2</sub>: Hecha completa a traves de una instancia de ``VentanaRanking`` que corresponde al frontend y una de ``BackRanking`` que corresponde al backend
	*  :white_check_mark: Visualización<sub>2.1</sub> : La interfaz del frontend esta hecha con layouts por lo que no deberían superponerse.
	*  :white_check_mark: Funcionamiento<sub>2.2</sub> : La ventana de ranking muestra los ``NUMERO_RANKING``mejores jugadores, parámetro que esta en el archivo ``parametros.py``. Este ordenamiento lo realiza el backend, el cual recibe una señal cuando se abre la ventana, y procesa los mejores puntajes, enviandolos al frontend cuando ya están calculados. El codigo se encuentra en el archivo ``back_ranking.py`` en la carpeta ``backend`` y contiene una funcion que calcula los mejores puntajes basados en el archivo ``ranking.txt``que se creará en caso de no existir.  Mientras que el manejo de interfaz se encuentra en el archivo ``front_ranking.py`` y se encarga solamente de crear y actualizar elementos de interfaz.

*  :white_check_mark: Ventana de Juego<sub>3</sub>>: Hecha completa
	* :white_check_mark: :x: Generales<sub>3.1</sub> : Están puestos e implementados todos los elementos del enunciado, estos se despliegan y actualizan a traves de una instancia de la clase ``VentanaJuego`` pertenecienta al archivo ``front_juego``, además esta la opcion de jugar solo por unos segundos gratis del bonus. La tienda funciona con un ``DINERO_INCIAL`` que esta en los parametros. El boton salir cierra la ventana y vuelve al inicio pero se debe esperar como 2 segundos antes de volver a abrir el juego, esto sucede porque siempre que sale del juego se termina una posible ronda del juego en ejecución y esta espera un pequeño tiempo por si quedan flechas, y envia la señal de cerrar la ventana, por lo que si se sale y se empieza inmediatamente una nueva ventana de juego esta se cerrará.
	* :white_check_mark: Fase Pre Ronda<sub>3.2</sub> : Para empezar se debe seleccionar un pinguino y vienen unas canciones y dificultad por default que pueden ser modificadas para empezar la cancion o dificultad que se desee. La tienda funciona correctamente, y el drag and drop funciona, el funcionamiento lógico general esta en el backend del juego, que se encuentra en el archivo ``back_juego``, y contiene a la clase ``BackJuego`` que se encarga del manejo general de la logica de dicha ventana. La validez de compra y el descuento del dinero están en los metodos ``manejar_dropeo`` que se encarga de aceptar el pinguino si este esta en la pista de baile y si no se superpone con otro **sprite de pinguino** (una nota importante es que como los sprites tienen un pequeño espacio sobrante pues están mal recortados los pinguinos, aunque el pinguino visible de repente no este superpuesto, el sprite si lo está por lo que no se puede dropear el pinguino, esto lo asumí así pues los sprites deberían estar siempre bien recortados). Luego de aceptada la compra hay otro metodo ``realizar_compra``que descuenta el dinero de la tienda, toda la información se envia a través de señales al frontend de la ventana de juego y los atributos estan hechos con propertys para que las señales se envien una vez cambiado los parametros. Por otro lado, la dificultad y cancion se pueden seleccionar correctamente, y una vez que se presiona el boton comenzar se envia todo al metodo ``setear_ronda`` del backend, el cual actualiza los parametros para la ronda que se va a jugar, donde ``ronda`` es una instancia de la clase ``Ronda`` del archivo ``ronda.py``, y dicha instancia es un atributo del backend del juego que se encarga de la mayoría de los procesamientos del juego de las flechas en si.
	* :white_check_mark: Fase Ronda<sub>3.3</sub> : Como se dijo antes, de esto se encarga la instancia ``back_juego``  con su atributo ``ronda`` el cual reproduce la cancion, maneja la duración del nivel, marca las zonas de captura, etc. Al desarrollarse el juego, se van actualizando las estadisticas dentro de ``back_juego.ronda`` y estas son enviadas por medio de señales por las propertys que están en la clase ``Ronda``. El cálculo de aprobación se encuentra en el archivo ``ronda.py`` en la clase ``Ronda`` en el metodo ``calcular_aprobación``. Por último la duración de la ronda esta dada por un timer de ``Ronda`` el cual se encarga de terminar la ronda al termianarse el tiempo, llamando a los metodos ``terminar_1`` y ``terminar_2``de ronda los cuales envian las señales necesarias para reactivar el botón comenzar entre otras cosas.
* :white_check_mark: Fase Post Ronda<sub>4</sub> : Una vez terminada la ronda se envían todas las estadisticas con una señal del objeto ``ronda`` al back del juego, quien calcula las estadisticas y determina si el usuario aprueba o no la ronda, y envia los datos de la partida a la ``ventana de resumen`` (que pertenece al archivo ``front_resumen``) para que esta se despliegue correctamente con la información. El calculo de puntaje se encuentra en el archivo ``ronda.py`` en el método ``calcular_puntaje``

* :white_check_mark: :x: Mecanicas<sub>5</sub> : Se implementa todo menos el poder de la flecha de hielo, y hay un caso de los tipos de pasos que no funciona.
	* :white_check_mark: Pinguirin<sub>5.1</sub> : El funcionamiento general del pinguino esta dado por la clase ``Pinguino`` la cual pertenece al archivo ``pinguinos.py`` de la carpeta ``entidades``, estos reciben una señal cada vez que un paso es correcto con las direcciones de las flechas que pertenecen a ese paso, y a través del metodo ``bailar`` gestionan que paso van a hacer segun las flechas, y luego vuelven a su posición neutral.
	* :white_check_mark: :x: Flechas<sub>5.2</sub> : Las flechas se mueven de manera mas o menos fluida dependiendo de la ``TASA_DE_REFRESCO`` utilizada, estas son instancias de la clase ``Flecha`` y siempre estan contenidas en una instancia de la clase ``Paso``, pues el funcionamiento esta dado que si se genera un paso, es este el que se mueve y envia señales para que cada flecha use el metodo ``mover`` que cambia la posición de la flecha y (a través de una property) envía la posición de la flecha a frontend del juego para que ajuste el label de la flecha y se note el movimiento.
Por otro lado, se implementan todos los tipos de flecha como subclases de la clase ``Flecha``, y todas funcionan correctamente excepto la ``FlechaHielo``, en  la cual o se implemento su poder.
Por último, la identificación de un paso correcto o incorrecto la hace el objeto ``Ronda`` del back del juego, el cual recibe el conjunto de teclas que fueron presionadas (Notar que presionar significa que este apreta todas las teclas necesarias y debe levantarlas también, pues dejar apretada la tecla no cuenta como un movimiento), y a través del metodo ``revisar_teclas``, ``pasos_en_zona_de_captura``, ``revisar_paso`` y ``revisar_flechas`` logra discriminar si el objeto ``Paso`` se encuentra en la zona de captura, luego revisa si el paso es correcto según las teclas presionadas y se encarga de capturar cualquier flecha que haya sido presionada (Sin importar si el paso fue correcto o no). El unico caso en que no funciona de manera correcta esta revisión es si hay 2 pasos al mismo tiempo en la zona de captura puesto que si por ejemplo el paso 1 contiene una flecha a la izquierda y el paso 2 contiene otra a la derecha y se presionan ambas teclas al mismo tiempo, cada paso recibirá ambas teclas en el método ``revisar_paso``, y sería como si hubiera apretado dos teclas cuando solo tenía que apretar 1 por lo tanto lo toma incorrecto :sob:, pero si solo hay un paso en la zona de captura se evaluan bien tanto si es combinado como si es normal de la misma manera.
PD: Es muy importante notar que el input del usuario se envia con el ``keyRealeaseEvent`` por lo que la "jugada" se envia solamente si se presionan y sueltan las teclas al mismo tiempo, y no si solamente se presionan. Además ciertos teclados de membrana no son capaces de enviar 3 teclas al mismo tiempo lo que podría generar problemas con dichos tipos de teclados.
* :white_check_mark: Funcionalidades Extra<sub>6</sub> : Tanto la pausa como los cheatcodes de las funcionalidas extra funcionan, la pausa se envía como señal del frontend del juego al backend del juego, y las teclas se envian segun las teclas que apretó el usuario con el ``keyRealeaseEvent`` al backend del juego, quien se encarga de discriminar si las teclas efectivamente corresponden a un cheatcode o no.
	* :white_check_mark: Pausa<sub>6.1</sub>: Esta es activada por el botón de pausa o por la letra P del teclado, se envia una señal desde la ``ventana_juego`` al ``back_juego`` quien se encarga de detener todos los Qtimers que hacen que funcione el juego (duración del nivel, generacion de pasos, musica, movimiento de los pasos (y por consecuencia de las flechas), entre otros). Luego si es que el juego esta pausado se puede reanudar, y empiezan nuevamente todos los qtimers y el juego vuelve a funcionar, además el timer con la duración del nivel se ajusta al tiempo restante del nivel que quedaba. Una nota es que si se pausa y reanuda repetidamente y muy rapido el juego este se puede buguear y la generación de pasos se mantiene infinitamente (solo en algunas ocasiones), por lo que por favor no presione y despresione la tecla P demasiado rápido).
	*  :white_check_mark: Cheat Codes<sub>6.2</sub>: Al presionarse cualquier conjunto de teclas estas se envian al metodo ``revisar_cheatcodes`` del backend del juego y revisa si corresponde a algun cheat implementado. Una nota es que si se tiene seleccionada una ``ComboBox`` de las opciones de dificultad y canción, no se pueden realizar cheatcodes pues los ``keyEvents`` que se encargan de las entradas de teclado, por funcionamiento interno de PyQt5, solo se envian a las ``ComboBox`` y no la widget principal.
		*  :white_check_mark:  M + O + N<sub>6.2.1</sub> En caso de activarse este cheatcode se llama al metodo ``cheat_dinero`` del backend y se agrega dinero a la tienda. Ya sea si la tienda esta visible o escondida.
		* :white_check_mark:  N + I + V<sub>6.2.2</sub> si
	se presiona este conjunto de teclas se llama a ``cheat_niv`` el cual termina el nivel actual inmediatmente. 
* :white_check_mark: General<sub>7</sub>: 
	*  :white_check_mark: Modularización<sub>7.1</sub>:  Todas las ventanas del juego están separadas en dos instancias una de backend y otra de frontend, las cuales pertenecen a clases especificas de backend y front end, todo esto se encuentra modelado en las archivos de las carpetas ``backend`` y ``frontend`` que contienen los archivos con las clases necesarias.
	*  :white_check_mark: Modelación<sub>7.2</sub>:  Para tener alta cohesión se hicieron cada backend por separado, cada entidad (como flechas y pinguinos) por separado, y y cada frontend de las ventanas tambien separadas. Todas estas se llaman en el archivo ``main.py`` que es el que instancia todo, y connecta todas las señales que comunican dichas instancias para lograr un bajo acoplamiento del programa como se puede apreciar en el codigo de dicho archivo.
	*  :white_check_mark: Archivos<sub>7.3</sub>: Se utilizan los archivos de sprites y songs de manera que se guardan las rutas de ellos en los parámetros, y luego se importan los parametros en el programa como se especificaba en el enunciado. Como se dijo antes, se debe copiar y pegar la carpeta ``sprites`` y ``songs`` a la carpeta ``T02`` para que estos se carguen correctamente tanto en las cosas definidas en codigo, como las puestas en las interfaces a traves de designer.
	*  :white_check_mark: Parametors<sub>7.4</sub>:  Todos los parametros se encuentran en el archivo ``parametros.py`` y además se encuentran algunos adicionales como la ``TASA_DE_REFRESCO`` entre otros que pueden ser cambiados y se verán reflejados en el funcionamiento del programa.

* :white_check_mark: Bonus<sub>8</sub>:  Se implemento tanto el bonus de cheatcodes adicionales como el bonus de segundos gratis, ambos funcionan correctamente.

## Ejecución :computer:
El módulo principal de la tarea a ejecutar es  ```main.py```. Además se debe crear los siguientes archivos y directorios adicionales:
1.  Carpeta ```sprites``` en ```T02``` que deben ser los mismos sprites que se subieron en el syllabus
2. Carpeta ``songs`` en ``T02`` que debe contener ambas canciones al igual como estaban en el syllabus

## Librerías :books:
### Librerías externas utilizadas
Las librerías externas utilizadas fueron ``PyQt5``, y el resto fueron solo librerias internas como

1. ```random```

### Librerías propias
Por otro lado, los módulos que fueron creados fueron los siguientes:

* Carpeta ``backend``

1. ```back_inicio```: contiene ``BackInicio`` que se encarga de la logica tras la ventana de inicio
2. ```back_juego```: contiene ``BackJuego`` que se encarga de la logica tras la ventana de juego, ya sea del manejo de entradas de usuario como de la ronda en funcionamiento a traves de su atributo ``ronda`` 
3. ``back_ranking`` : contiene ``BackRanking`` que tiene los metodos ``ordenar_puntaje`` que ordena los puntajes del archivo ``ranking.txt`` y el metodo ``escribir_puntaje`` que escribe un nuevo puntaje en el archivo ``ranking.txt``
* Carpeta ``frontend``
4. ``front_inicio`` : contiene ``VentanaInicio`` la cual corresponde al frontend de la ventana de inicio y envia todas las señales al backend de botones apretados entradas de texto, etc.
5.  ``front_juego`` : contiene ``VentanaJuego`` que corresponde al frontend del juego y se encarga de enviar todas las entradas de usuario como botones presionados, teclas presionadas etc. al backend del juego.
6. ``front_ranking`` : contiene ``VentanaRanking``que crea la ventana de ranking y envia las señales correspondientes cuando se abre la ventana y cuando se cierra.
7. ``front_resumen``: contiene ``VentanaResumen`` que se encarga del frontend y GUI de la ventana de resumen, y envia las señales correspondientes cuando se presiona el botón volver en caso de que haya que ir a la ventana de inicio o de juego.
* Carpeta ``entidades``
8. ``flechas``: Contiene ``Flecha(QLabel)`` la cual es la clase padre de  ``FlechaNormal``, ``FlechaDorada``, ``FlechaX2`` y ``FlechaHielo`` las cuales modelan las distintas flechas y deben estar contenidas por composicion en una instancia de la clase ``Paso(QTimer)``.
9. ``pasos``: Contiene ``Paso`` que modela los diferentes tipos de pasos ya sean normales o combinados, y que contiene a las flechas del paso, estas son todas del mismo tipo para un mismo paso. Además el modulo contiene a la clase  ``GeneradorPasos(QTimer)`` la cual es un objeto que es capaz de generar pasos a una velocidad ``TIEMPO_ENTRE_PASOS`` y dependiendo de la dificultad entre otras cosas va generando los pasos segun la probabilidad de cada tipo de flecha.
10. ``pinguinos`` : contiene a la clase ``Pinguino(QLabel)`` la cual modela al pinguino ya sea los de la tienda o los introducidos en la pista de baile.
* Carpeta principal ``T02``
11. ``ronda``: Contiene a la clase ``Ronda`` la cual se encarga de hacer funcionar todas las cosas internas de cada ronda como la revisión de los pasos, los calculos de estadisticas, los manejos de los combos, los pasos generados, los pasos correctos, incorrectos, en fin, todo lo interno al juego de las flechas en si.

## Supuestos y consideraciones adicionales :thinking:
Los supuestos que realicé durante la tarea son los siguientes:

1. El jugador no entrará y saldrá de la ventana de inicio y volverá al juego de manera tan rápida
2. El jugador debe apretar y soltar las teclas para que estas sean procesadas, puesto que solo apretar las teclas no se considera como una acción puesto que nunca se presionaran exactamente al mismo tiempo, por lo que se deben presionar todas y luego ser soltada al menos una para que se envien las teclas, esto como se ve simula muy bien el "al mismo tiempo" de las teclas.
3. No se tratarán de modificar los tamaños de las ventanas, y el usuario tendrá un monitor lo suficientemente grande para que estas quepan
4. El jugador cambiara la ``TASA_DE_REFRESCO`` dependiendo de las caracteristicas de su computador para que este funcione de manera correcta al igual que en otros juegos se puede subir y bajar la calidad grafica de los juegos.
5. Si se realiza la acción de pausa desde el boton se reanudara desde el botón y si se hace como cheatcode (presionando la P) se reanudara usando el mismo cheatcode.
6. Las teclas que se pueden modificar en los parametros siempre serán caracteres, puesto que no se pueden poner las "flechitas" como string en los parametros y los codigos de las teclas no son lo suficientemente "intuitivos" ni universales para usarlos como parámetro a diferencia de los caracteres.


## Referencias de código externo :book:

Para realizar mi tarea vi codigo de algunas partes pero este fue modificado, esta fue de :
1. https://stackoverflow.com/questions/7176951/how-to-get-multiple-key-presses-in-single-event el cual daba una idea de como manejar multples teclas, pero luego fue modificado para uso propio.
2. El resto hice casi pura lectura de la documentación oficial de PyQt5, ya sea la de python o la de C++, que se encuentra en:
https://doc.qt.io/qtforpython/