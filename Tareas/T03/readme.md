

# Tarea 03: DCColonos

## Consideraciones generales 

El programa logra hacer la mayoria de las cosas pedidas, se implementa casi todo, pero no se implementaron los caminos a nivel grafico, y faltan un par de cosas de los caminos a nivel logico (Se explica mas adelante con mas detalle), el juego corre una partida de manera correcta, pero el servidor no es capaz de jugar una segunda partida seguida sin cerrar los clientes anteriores y volviendo a correr el archivo main del servidor, por lo que para probar todos los funcionamientos se puede ajustar como quiera los parametros, y jugar con tranquilidad una partida completa, pero para probar distintas partidas se debe volver a correr el servidor y los clientes. Por otro lado, explicando brevemente el funcionamiento cliente servidor, el servidor y el cliente tienen una clase Server que se encuentra en ``networking.py`` y es la encargada de realizar las serializaciones, recibir y intercambiar informacion a traves de los sockets cliente-servidor, asi, todo el flujo de datos pasa por esta clase, pero adem谩s hay otra clase en el mismo archivo que se llama ``Interfaz{Server/Client}Net``, que es la que se encarga de "Acceder" a dicho networking tanto del cliente como del servidor que intercambia la informaci贸n, esto significa que usa locks para entrar en laz "zonas criticas" como lectura de comandos que se acumulan en el servidor, o envio de comandos a traves del socket del servidor, para evitar concurrencia en el programa y lograr la correcta ejecuci贸n cronologica de todos los comandos y operaciones a realizar tanto en el cliente como en el servidor. As铆, esta interfaz se instancia en el mismo archivo y es importada en las diferentes partes del codigo que necesiten "enviar o recibir algo", y como todas lo hacen a traves de esta misma interfaz (Que no debe confundirse con una interfaz gr谩fica, sino que es una interfaz de acceso al networking del servidor o del cliente) no existe concurrencia aunque varias clases, entidades, o Threads distintos quieran usar el networking del programa. Por ultimo, para la mayor铆a de las implementaciones de las distintas reglas del DCColonos, el flujo es el siguiente
Instancia_que_manda_o_lee_algo  -> InterfazServerNet -> ServerNet -> Se serializa y envia la informacion -> ClientNet -> InterfazClientNet -> BackCliente -> FrontCliente.
Es decir, se va pasando por diferentes capas de abstracci贸n para lograr implementar cosas nuevas de manera sencilla y sin concurrencia a traves de comandos, pero esta realizaci贸n por pasos logra evitar concurrencia y simplificar la codificaci贸n y mantenci贸n del programa.

### Cosas implementadas y no implementadas :white_check_mark: :x:

* :white_check_mark: :x:Networking<sub>1</sub>: Hecha casi completa.
En el archivo ``networking.py`` ubicado en la carpeta ``backend``, y en el archivo ``networking.py`` ubicando en la carpeta ``server`` se encuentra todo lo referente al networking de ambos programas (Cliente y servidor), donde como se explico antes, existe una clase Server/ClientNet que se encarga del manejo de sockets, threads de aceptar clientes, threads, de escucha, serializaci贸n, envio de bytes, de comandos, etc..., y tambien est谩 la ``Interfaz(Cliente/Server)Net`` que sirve de acceso a este networking de manera no concurrente a traves de locks. Adem谩s se instancian ambas clases en el mismo archivo para poder ser importada la interfaz del networking y comprartirla en las diferentes partes del programa
	* :white_check_mark: Protocolo<sub>1.1</sub>:  En el ``__init__`` del servidor y del cliente se instancia el socket usando el protocolo TCP/IP usando los parametros dados en ``Parametros.json`` en el host y el port (Se testio el programa usando de host el nombre del equipo, y el puerto 200, y en una red LAN, usando diferentes computadores conectados a un mismo router).
	* :white_check_mark: Correcto uso de sockets<sub>1.2</sub>: Los sockets se instancian como se dijo antes en el ``__init__`` de las clases de Networking, y ademas se tienen try/excpet/finally para lograr siempre cerrar los sockets en caso de cualquier error. En el caso del servidor, este se pone a escuchar segun el ``host`` y ``port`` pasado en los ``parametros.json`` con el metodo ``encender`` el cual llama a ``bind_and_listen`` y logra conectar y poner a escuchar el server, y corre un thread de aceptar clientes. Por otro lado en el caso de los clientes, se llama a ``encender `` el cual llama al m茅todo ``connect`` que conecta el socket al servidor y inicializa los threads que escuchan el servidor, y el thread que revisa los comandos que van llegando  a la cola del servidor.
	Tambi茅n se logra trabajar la aplicacion concurrentemente, pues se implementaron threads de escucha a cada clietne por separado en el servidor. Y tambi茅n para evitar concurrencia se hizo una estructura en cada networking para ir recibiendo "comandos" que se explicar谩n a continuaci贸n, pero estos van llegando a una cola del servidor con estructura de datos FIFO, y a trav茅s de locks, estos se van leyendo de uno en uno tanto en el cliente como en el servidor, lo que asegura una correcta secuancia en la realizaci贸n de comandos, y evita errores inesperador por concurrencia.
	*  :white_check_mark: Conexi贸n<sub>1.3</sub> : Como se puede apreciar en el funcionamiento del programa, la conexi贸n es sostenida en el tiempo, pero me gustar铆a aclarar aqu铆 como funcionan estos "comandos" que se envian entre cliente y servidor. Estos son instancias de la clase ``Comando``, definida en el archivo ``comando.py`` , y son los mensajes que se envian a trav茅s de los sockets, estos contienen un string que indica la instrucci贸n a realizar, y en caso de ser necesarios, los parametros para realizar dicha acci贸n, a modo de ejemplo podemos decir que si el servidor debe realizar la acci贸n suma, el cliente envia un comando de la forma ``Comando("add", 5, 4, 9)`` donde el servidor a usando la interfaz para el networking, y accediendo a la cola del servidor donde se van a  acumular estos comandos, logra sacar el comando de la cola, y ejecutarlo en la parte donde se corre dicho comando, por lo mismo, los strings para los comandos son unicos, y estan escritos en ingl茅s, a modo de ID 煤nico para no tener problemas con las distintas partes del programa. As铆 diferentes clases del programa tienen diferentes diccionarios de comandos de la forma ``{"nombre_comando": metodo}``, linkeando cada comando al metodo especial a ejecutar, esto entonces abstrae la forma de implementar cosas nuevas para tener un funcionamiento general mas f谩cil de manejar y menos concurrente, y permite a帽adir nuevas funcionalidades sin afectar las ya implementadas.
	*  :white_check_mark: :x: Manejo de clientes<sub>1.4</sub> : En el caso del manejo de los clientes por el servidor, se pueden conectar varios y desconectar sin afectar el funcionamiento del servidor, esto se ejemplifica de mejor manera en la sala de espera, donde se pueden conectar y desconectar clientes, hasta que se llene la sala y ahi reci茅n parte el juego. Por otro lado, por temas de implementaci贸n, los clientes cuando ya se est谩 dentro de una partida, no se pueden desconectar, pues la partida aun estara "esperando" algunas de sus acciones, pero no se cae el programa cuando este se desconecta. Por 煤ltimo, la caida inesperada del servidor no se manejar de manera correcta, solamente esta el caso de que si un cliente se conecta, y el servidor esta "caido", se muestra en consola que el servidor no esta disponible manejando el error de conexion.
*  :white_check_mark: Arquitectura Cliente Servidor <sub>2</sub>: Hecha completa, los roles est谩n claramente separados, de hecho, ninguna de las clases logicas del juego (Por ejemplo ``Mapa``, ``Usuario`` , ``Banco``, entre otras) no estan contenidas en el programa de cliente, todo se envia al servidor, y este maneja todos los datos a nivel logico en las diferentes clases del juego. Luego de procesada la informaci贸n se env铆a solo lo necesario para actualizar la interfas de el/Los clientes seg煤n corresponda, esto se hace usando los metodos de la interfaz de networking ``send_command`` y ``send_command_to_all`` que envian comandos a uno o varios clientes respectivamente. Un buen ejemplo es cuando se tiran los dados, donde el cliente notifica al servidor que apret贸 el bot贸n, los dados se tiran a nivel l贸gico en la clase ``Juego``, ``lanzar_dados`` del archivo ``juego.py``, y estos numeros de dados son enviados a las interfaces de todos los clientes usando la linea ``interfaz_network.send_command_to_all("update_dices", dado_1, dado_2)``, es decir solo se envian los numeros que se deben mostrar en la interfaz al backend del cliente, que posteriormente envia una senal al frontend del cliente para actualizar los dados, (Es una especie de burocracia, pero mantiene los Roles bien separados).
	* :white_check_mark: Roles<sub>2.1</sub> : A nivel espec铆fico de roles, el servidor contiene toda la logica del juego, en todos los archivos que estan contenidos en la carpeta ``juego``, lo que incluye generaci贸n del mapa, robo de cartas, lanzamiento de dados, validaci贸n de costos de compras, validaci贸n de construcciones en el mapa, entre muchas otras cosas. Mientras que por otro lado, el cliente solo tiene funcionamiento l贸gico/gr谩fico (Osea lo que no es networking) como backend  en la carpeta ``backend`` y frontend en la carpeta ``frontend``, los cuales se encargan en primer lugar de habilitar o bloquear los widgets de Input del usuario seg煤n se lo envie el servidor (pues este maneja los turnos), en segundo lugar, de actualizar la informaci贸n que se muestra en la interfaz del jugador seg煤n, los datos que valla enviando el servidor (Ejemplo claro de ello son cuando se cargan las materias primas y los numeros de fichas en la interfaz, seg煤n los datos que manda el servidor cuando carga el mapa). Adem谩s como ejemplo de validaci贸n se tiene cuando se compran casas o cartas de desarrollo, donde a trav茅s del ``Banco`` se validan y notifican las compras, y a trav茅s del ``Mapa`` se validan las adyacencias de construcciones. Por 煤ltimo, en la parte de "Almacenar y actualizar", se hicieron propertys para todas las clases del juego, cosa que cada vez que alguien gane un punto, construya algo, gane materias primas, entre otras cosas, esta informaci贸n se envia a todos los usuarios para que se actulizen sus interfaces usando el networking del servidor.
	* :white_check_mark: Consistencia<sub>2.2</sub> : Se puede ver con el funcionamiento que todo se va actualizando, y para uso de locks, como se ha mencionado varias veces, como a nivel de networking todos usan la misma ``InterfazNet``, todos usan los mismos locks para acceder al networking, especificamente se implementaron locks en esta clase para:
		* 1) Enviar Comandos a los clientes
		* 2) Sacar comandos de la cola de comandos del servidor para su posterior ejecucion (Estructura FIFO)
	* :white_check_mark: Logs<sub>2.3</sub>: Se implementaron los logs seg煤n lo que indicaba el enunciado, donde se muestra un log cada vez que se a帽ade un comando, y cada vez que se realiza, adem谩s de todas las cosas pedidas en el enunciado (Mis logs muestran practicamente todo lo que pasa en el programa :smile: y como se van comunicando y ejecutando las cosas), y adem谩s se usa un lock para imprimir logs para que estos no se "solapen" al imprimirse en la consola.

* :white_check_mark: Manejo de Bytes :zero::one::zero::one::one:<sub>3</sub> : Hecha Completa
	* :white_check_mark: Codificaci贸n 垛★<sub>3.1</sub> : La codificaci贸n est谩 implementada tanto en cliente como en servidor en el archivo ``networking`` en la clase ``Server/ClientNet``, especificamente en el m茅todo ``send_bytes`` el cual recibe bytes, y aplica el protocolo de codificaci贸n dado en el enunciado, adem谩s la serializaci贸n misma de los objetos se hace en los m茅todos ``send_comand`` y ``send_commando_to_all`` los cuales serializan com pickle los comandos que luego se envian a los clientes/servidor seg煤n corresponda, siguiendo la logica:
	send_command -> Bytes -> send_bytes -> BytesCodificadosConElProtocolo -> se envian los bytes
	* :white_check_mark: Decodificaci贸n 光★<sub>3.2</sub> : La decodificaci贸n se encuentra en la clase ``Server/ClientNet`` en el archivo ``networking.py``, espec铆ficamente en el metodo ``recive_data`` el cual se encarga de decodificar los bytes enviados con el protocolo del enunciado, y retorna los bytes originales, que luego son deserializados seg煤n corresponde usando pickle, en el ``thread_de_escucha_cliente/servidor``, decodificando el comando mandado.
	* :white_check_mark: Integraci贸n<sub>3.3</sub>: Como se dijo antes, tanto en el envi贸 como decodificaci贸n se integra el protocolo de envio de mensajes (Que en mi caso estos mensajes siempre son los comandos que se explicaron mas arriba).

* :white_check_mark: :x: Interfaz Grafica<sub>4</sub>: 
	*  :white_check_mark: Modelaci贸n <sub>4.1</sub>:  Se hizo una separacion frontend/backend de la interfaz del cliente, donde el frontend solo instancia y actualiza los widgets de la interfaz, y le envia al backend las acciones realizadas en la interfaz, mientras que es el backend el que maneja todos los comandos que llegan al networking del cliente, y envia se帽ales para que se actualizen todos los elementos de la interfaz, asi como tambi茅n recibe senales del frontend con los widgets de inputs usados, y envia los comandos respectivos al servidor para que este responda y el DCColonos funcione.
	*  :white_check_mark: Sala de Espera<sub>4.2</sub>:  Se actualiza correctamente, y  no deja entrar al servidor en el caso de que ya este lleno, mostrandose un mensaje acorde.
	*  :white_check_mark::x: Sala Juego<sub>4.3</sub>: Se implementa todo lo pedido, excepto que no se pueden comprar caminos, y el bot贸n de sala de espera no redirige a la sala de espera porque no tiene sentido, puesto que no se pueden jugar dos partidas seguidas sin volver a correr el servidor y los clientes.
	*  :white_check_mark: Fin de la partida<sub>4.4</sub>:  Al llegarse a los puntos necesarios para ganar se finaliza la partida y se muestra una ventana que muestra los resultados, notificando si gan贸 o perdi贸 , y mostrando todos los puntajes de forma ordenada.

* :white_check_mark: :x: Grafo <sub>5</sub>:  El funcionamiento del grafo se encuentra en el servidor en la carpeta ``juego\mapa``, donde se encuentran los archivos ``grafo.json`` y el archivo ``mapa.py``, este 煤tlimo contiene las clases ``Nodo`` que representa los vertices del grafo, la clase ``Hexagono`` que modela los hexagonos y la clase ``Conexion`` que representa las aristas del grafo y los caminos del juego. Todas estas se llaman en la clase ``Mapa``la cual modela todo el mapa del juego.
	*  :white_check_mark: Archivo <sub>5.1</sub> : En el metodo ``cargar_mapa`` de clase mapa se carga el archivo ``grafo.json`` y se instancia todo el mapa, junto con los nodos, hexagonos, numeros de fichas, etc...
	* :white_check_mark: Modelacion <sub>5.2</sub> : Se usan propertys para actualizar todos los datos cuando se carga el mapa, enviando la informacion a todos los usuarios jugando.
	* :white_check_mark: :x: Funcionalidades <sub>5.3</sub> : Si se verifica que se cumplan las restricciones para construir una choza, pero solamente que no haya una choza en un nodo adyacente, porque como se dijo al principio, no se implementaron los caminos. Adem谩s, aunque si se puede a帽adir un camino al mapa a nivel l贸gico, como no est谩s implementados, no se muestran en la interfaz. y no se revisan las restricciones de construcci贸n de estos, por 煤ltimo, se encuentra en la clase un m茅todo ``carretera_mas_larga`` que calcula el camino mas largo segun los caminos puestos en el mapa usando backtracking, incluso en el ``if __name__ == __main__``de el archivo mapa se muestra un ejemplo instanciando algunos caminos, y el algoritmo funciona, solo que no filtra que sean de un mismo usuario, y como se dijo, no est谩 implementado a nivel gr谩fico, pero para probar dicho main deben comentarse las lineas de envio de comandos entre otras cosas, pero en el fondo el algoritmo lo que hace es ir avanzando de nodo en nodo contando caminos construidos hasta llegar a un camino que no puede seguir, luego vuelve hacia atras descontando los caminos, hasta que llega a un nodo que aun tenia caminos por recorrer, recorriendo asi todos los caminos que conectan los nodos, una vez que todos fueron visitados, el algoritmo se devuelve hasta el nodo inicial, finalizando el algoritmo y devolviendo los largos de los caminos desde el nodo inicial, iterando sobre todos los nodos y sacando el m谩ximo, se encuentra efectivamente la carretera mas larga.

* :white_check_mark: :x: Reglas DCColonos <sub>6</sub> : Se cumplen todas las reglas, pero no las que involucran caminos, puesto que estos no se implementan.
	* :white_check_mark: :x: Inicio Juego <sub>6.1</sub> : Hecho completo pero sin caminos.
	*  :white_check_mark: lanzamiento de Dados <sub>6.2</sub> : Hecho completo incluido con el 7 el cual bota materias primas aleatorias y lo notifica a los jugadores, los dados se actualizan en todas las interfaces y se reparten las materias primas
	* :white_check_mark: :x: Turno <sub>6.3</sub> : Se hace todo menos la carretera mas larga, la implementaci贸n del punto de victoria se encuentra en el servidor en ``juego\juego.py`` donde se llama a la funcion ``comprar_carta_desarrollo`` cuando el jugador de turno apreta el boton de carta de desarrollo, este le envia al banco la acci贸n para validar la compra y el banco de la clase ``Banco`` en el archivo ``banco.py`` de la carpeta ``entidades`` en el metodo ``comprar_carta_desarrollo`` valida el precio y usa el archivo entregado en el enunciado para sacar una carta de desarrollo, y instanciar la carta pedida, esta instancia de carta la retorna al juego quien la activa inmediatamente y muestra un ``Qdialog`` en la interfaz para notificar o realizar la acci贸n que ocurre (Ya sea punto de victoria o Monopolio), esta acci贸n adem谩s se notifica a todos los jugadores. 
	* :white_check_mark: Termino del juego<sub>6.4</sub> : Hecho completo
* :white_check_mark: General <sub>7</sub> : Hecho completo
	* :white_check_mark: Parametros <sub>7.1</sub> : Se tiene un  archivo de parametros para cada programa (Cliente y Servidor) y se llaman usando json cuando se necesitan.
	* :white_check_mark: Grafo <sub>7.2</sub> : Se utiliza y carga en el metodo ``cargar_mapa`` ya mencionado de la clase ``Mapa``
	* :white_check_mark: Generador de mazos <sub>7.3</sub> : Se usa el metodo ``sacar_cartas`` en la clase ``Banco`` cuando se quiere comprar una carta de desarrollo como se explic贸 antes.
* :white_check_mark: Bonus <sub>8</sub> : Se implementa el bonus de ladron (Que tiene la cara del profe ) y tamb铆en se implementa la ventana de chat.
## Ejecuci贸n :computer:
Los modulos principales de la tarea son los archivos ``main.py `` del servidor que se debe correr en primer lugar, y el archivo ``main.py`` del cliente que se deben correr (para abrir varios clientes) despu茅s de correr el main del servidor. Adem谩s se deben poner archivos en las carpetas especificadas como se indica a continuacion:
1.  Carpeta ```sprites``` dentro de ```T03\client``` que deben ser los mismos sprites que se subieron en el syllabus.
2. Archivo ``ladron.png`` y ``exchange_icon.png`` que se subieron en la carpeta raiz se deben ubicar en la carpeta sprites del cliente antes mencionada.
3. Archivo ``grafo.json`` dentro de ``T03\server\juego\mapa`` que corresponde al archivo pasado en el syllabus.
4. Archivo ``generador_de_cartas.py`` dentro de ``T03\server\juego\entidades`` que corresponde al archivo pasado en el syllabus.

## Librer铆as :books:
### Librer铆as externas utilizadas
Las librer铆as externas utilizadas fueron ``PyQt5``, y ``Faker`` y por tanto deben estar instaladas para que corra el programa, el resto fueron librerias built-in como:

1. ```random```
2. ``collections``
3. ``threading``
4. ``socket``
5. ``sys``
6. ``time``

### Librer铆as propias
Por otro lado, los m贸dulos que fueron creados fueron los siguientes:

Por el lado del servidor
* ``comando.py``: Contiene ``Comando`` el cual modela un comando para enviar entre cliente y servidor.
* ``networking``: Contiene ``ServerNet`` el cual modela el networking del servidor con serializacion, protocolo de envio, manejo de comandos etc. y contiene ``InterfazServerNet`` que modela un objeto de acceso al ServerNet y luego se instancia en el mismo archivo para ser compartido en todas partes la misma instancia y acceder al networking sin problemas de concurrencia.
* Carpeta ``juego\``
	* ``mapa\``
		1. ```mapa.py```: contiene ``Nodo``, ``Conexion``, ``Hexagono`` y ``Mapa`` que se encarga de la modelaci贸n del grafo del mapa y los atributos para el juego.
	* ``items\``
		1) ``carta_desarrollo.py``: Contiene ``CartaDesarrollo``, ``CartaPuntoVictoria``, ``CartaMonopolio`` que modelan las distintas cartas de dasarrollo.
		2) ``construcciones.py``: Contiene ``Choza``, ``Ciudad``, ``Camino`` que modelan las construcciones del juego.
		3) ``mazo.py``: Contiene ``Mazo`` que es un diccionario personalizado que modela los mazos de los jugadores.
	* ``entidades\``
		1) ``usuario.py``: Contiene ``Usuario``que modela a un usuario que esta jugando en la partida con sus puntos su mazo, sus puntos de victoria, etc...
		2) ``banco.py``: Contiene ``Banco`` que modela el banco, quien valida las compras de construcciones revisando materias primas de los mazos del jugador y usa el modulo entregado para robar cartas de desarrollo.
## Supuestos y consideraciones adicionales :thinking:
Los supuestos que realic茅 durante la tarea son los siguientes:

1. Los jugadores una vez entrados a la partida no se iran AFK, pues el servidor no podr铆a saber que acciones se ivan a realizar (Este supuesto est谩 mal tomado porque en el fondo no implement茅 una desconexi贸n de un cliente "in game").
2. El jugador ser谩 cap谩z de reconocer los elementos de la interfaz, ya sea boton de carta de desarrollo, ficha de ladr贸n (El profe), boton de intercambio, etc.
3. Se pondr谩n el host y port en los parametros de manera que funcione de forma correcta el cliente y el servidor.
4. Para volver a jugar se correran denuevo el servidor, y los clientes que se van a conectar.
5. La interfaz creada siempre cabr谩 en la pantalla donde se va a jugar.

## Referencias de c贸digo externo :book:

No us茅 codigo externo en esta tarea, solo lei documentaci贸n de Pyqt5, Faker, y saqu茅 ideas de la materia de clases, pero sin copiar c贸digo.