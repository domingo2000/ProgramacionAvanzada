

# Tarea 03: DCColonos

## Consideraciones generales 

El programa logra hacer la mayoria de las cosas pedidas, se implementa casi todo, pero no se implementaron los caminos a nivel grafico, y faltan un par de cosas de los caminos a nivel logico (Se explica mas adelante con mas detalle), el juego corre una partida de manera correcta, pero el servidor no es capaz de jugar una segunda partida seguida sin cerrar los clientes anteriores y volviendo a correr el archivo main del servidor, por lo que para probar todos los funcionamientos se puede ajustar como quiera los parametros, y jugar con tranquilidad una partida completa, pero para probar distintas partidas se debe volver a correr el servidor y los clientes. Por otro lado, explicando brevemente el funcionamiento cliente servidor, el servidor y el cliente tienen una clase Server que se encuentra en ``networking.py`` y es la encargada de realizar las serializaciones, recibir y intercambiar informacion a traves de los sockets cliente-servidor, asi, todo el flujo de datos pasa por esta clase, pero además hay otra clase en el mismo archivo que se llama ``Interfaz{Server/Client}Net``, que es la que se encarga de "Acceder" a dicho networking tanto del cliente como del servidor que intercambia la información, esto significa que usa locks para entrar en laz "zonas criticas" como lectura de comandos que se acumulan en el servidor, o envio de comandos a traves del socket del servidor, para evitar concurrencia en el programa y lograr la correcta ejecución cronologica de todos los comandos y operaciones a realizar tanto en el cliente como en el servidor. Así, esta interfaz se instancia en el mismo archivo y es importada en las diferentes partes del codigo que necesiten "enviar o recibir algo", y como todas lo hacen a traves de esta misma interfaz (Que no debe confundirse con una interfaz gráfica, sino que es una interfaz de acceso al networking del servidor o del cliente) no existe concurrencia aunque varias clases, entidades, o Threads distintos quieran usar el networking del programa. Por ultimo, para la mayoría de las implementaciones de las distintas reglas del DCColonos, el flujo es el siguiente
Instancia_que_manda_o_lee_algo  -> InterfazServerNet -> ServerNet -> Se serializa y envia la informacion -> ClientNet -> InterfazClientNet -> BackCliente -> FrontCliente.
Es decir, se va pasando por diferentes capas de abstracción para lograr implementar cosas nuevas de manera sencilla y sin concurrencia a traves de comandos, pero esta realización por pasos logra evitar concurrencia y simplificar la codificación y mantención del programa.

### Cosas implementadas y no implementadas :white_check_mark: :x:

* :white_check_mark: :x:Networking<sub>1</sub>: Hecha casi completa.
En el archivo ``networking.py`` ubicado en la carpeta ``backend``, y en el archivo ``networking.py`` ubicando en la carpeta ``server`` se encuentra todo lo referente al networking de ambos programas (Cliente y servidor), donde como se explico antes, existe una clase Server/ClientNet que se encarga del manejo de sockets, threads de aceptar clientes, threads, de escucha, serialización, envio de bytes, de comandos, etc..., y tambien está la ``Interfaz(Cliente/Server)Net`` que sirve de acceso a este networking de manera no concurrente a traves de locks. Además se instancian ambas clases en el mismo archivo para poder ser importada la interfaz del networking y comprartirla en las diferentes partes del programa
	* :white_check_mark: Protocolo<sub>1.1</sub>:  En el ``__init__`` del servidor y del cliente se instancia el socket usando el protocolo TCP/IP usando los parametros dados en ``Parametros.json`` en el host y el port (Se testio el programa usando de host el nombre del equipo, y el puerto 200, y en una red LAN, usando diferentes computadores conectados a un mismo router).
	* :white_check_mark: Correcto uso de sockets<sub>1.2</sub>: Los sockets se instancian como se dijo antes en el ``__init__`` de las clases de Networking, y ademas se tienen try/excpet/finally para lograr siempre cerrar los sockets en caso de cualquier error. En el caso del servidor, este se pone a escuchar segun el ``host`` y ``port`` pasado en los ``parametros.json`` con el metodo ``encender`` el cual llama a ``bind_and_listen`` y logra conectar y poner a escuchar el server, y corre un thread de aceptar clientes. Por otro lado en el caso de los clientes, se llama a ``encender `` el cual llama al método ``connect`` que conecta el socket al servidor y inicializa los threads que escuchan el servidor, y el thread que revisa los comandos que van llegando  a la cola del servidor.
	También se logra trabajar la aplicacion concurrentemente, pues se implementaron threads de escucha a cada clietne por separado en el servidor. Y también para evitar concurrencia se hizo una estructura en cada networking para ir recibiendo "comandos" que se explicarán a continuación, pero estos van llegando a una cola del servidor con estructura de datos FIFO, y a través de locks, estos se van leyendo de uno en uno tanto en el cliente como en el servidor, lo que asegura una correcta secuancia en la realización de comandos, y evita errores inesperador por concurrencia.
	*  :white_check_mark: Conexión<sub>2.1</sub> : Como se puede apreciar en el funcionamiento del programa, la conexión es sostenida en el tiempo, pero me gustaría aclarar aquí como funcionan estos "comandos" que se envian entre cliente y servidor. Estos son instancias de la clase ``Comando``, definida en el archivo ``comando.py`` , y son los mensajes que se envian a través de los sockets, estos contienen un string que indica la instrucción a realizar, y en caso de ser necesarios, los parametros para realizar dicha acción, a modo de ejemplo podemos decir que si el servidor debe realizar la acción suma, el cliente envia un comando de la forma ``Comando("add", 5, 4, 9)`` donde el servidor a usando la interfaz para el networking, y accediendo a la cola del servidor donde se van a  acumular estos comandos, logra sacar el comando de la cola, y ejecutarlo en la parte donde se corre dicho comando, por lo mismo, los strings para los comandos son unicos, y estan escritos en inglés, a modo de ID único para no tener problemas con las distintas partes del programa. Así diferentes clases del programa tienen diferentes diccionarios de comandos de la forma ``{"nombre_comando": metodo}``, linkeando cada comando al metodo especial a ejecutar, esto entonces abstrae la forma de implementar cosas nuevas para tener un funcionamiento general mas fácil de manejar y menos concurrente, y permite añadir nuevas funcionalidades sin afectar las ya implementadas.
	*  :white_check_mark: :x: Manejo de clientes<sub>2.2</sub> : En el caso del manejo de los clientes por el servidor, se pueden conectar varios y desconectar sin afectar el funcionamiento del servidor, esto se ejemplifica de mejor manera en la sala de espera, donde se pueden conectar y desconectar clientes, hasta que se llene la sala y ahi recién parte el juego. Por otro lado, por temas de implementación, los clientes cuando ya se está dentro de una partida, no se pueden desconectar, pues la partida aun estara "esperando" algunas de sus acciones, pero no se cae el programa cuando este se desconecta. Por último, la caida inesperada del servidor no se manejar de manera correcta, solamente esta el caso de que si un cliente se conecta, y el servidor esta "caido", se muestra en consola que el servidor no esta disponible manejando el error de conexion.
*  :white_check_mark: Arquitectura Cliente Servidor sub>3</sub>: Hecha completa, los roles están claramente separados, de hecho, ninguna de las clases logicas del juego (Por ejemplo ``Mapa``, ``Usuario`` , ``Banco``, entre otras) no estan contenidas en el programa de cliente, todo se envia al servidor, y este maneja todos los datos a nivel logico en las diferentes clases del juego. Luego de procesada la información se envía solo lo necesario para actualizar la interfas de el/Los clientes según corresponda, esto se hace usando los metodos de la interfaz de networking ``send_command`` y ``send_command_to_all`` que envian comandos a uno o varios clientes respectivamente. Un buen ejemplo es cuando se tiran los dados, donde el cliente notifica al servidor que apretó el botón, los dados se tiran a nivel lógico en la clase ``Juego``, ``lanzar_dados`` del archivo ``juego.py``, y estos numeros de dados son enviados a las interfaces de todos los clientes usando la linea ``interfaz_network.send_command_to_all("update_dices", dado_1, dado_2)``, es decir solo se envian los numeros que se deben mostrar en la interfaz al backend del cliente, que posteriormente envia una senal al frontend del cliente para actualizar los dados, (Es una especie de burocracia, pero mantiene los Roles bien separados).
	* :white_check_mark: Roles<sub>3.1</sub> : A nivel específico de roles, el servidor contiene toda la logica del juego, en todos los archivos que estan contenidos en la carpeta ``juego``, lo que incluye generación del mapa, robo de cartas, lanzamiento de dados, validación de costos de compras, validación de construcciones en el mapa, entre muchas otras cosas. Mientras que por otro lado, el cliente solo tiene funcionamiento lógico/gráfico (Osea lo que no es networking) como backend  en la carpeta ``backend`` y frontend en la carpeta ``frontend``, los cuales se encargan en primer lugar de habilitar o bloquear los widgets de Input del usuario según se lo envie el servidor (pues este maneja los turnos), en segundo lugar, de actualizar la información que se muestra en la interfaz del jugador según, los datos que valla enviando el servidor (Ejemplo claro de ello son cuando se cargan las materias primas y los numeros de fichas en la interfaz, según los datos que manda el servidor cuando carga el mapa). Además como ejemplo de validación se tiene cuando se compran casas o cartas de desarrollo, donde a través del ``Banco`` se validan y notifican las compras, y a través del ``Mapa`` se validan las adyacencias de construcciones. Por último, en la parte de "Almacenar y actualizar", se hicieron propertys para todas las clases del juego, cosa que cada vez que alguien gane un punto, construya algo, gane materias primas, entre otras cosas, esta información se envia a todos los usuarios para que se actulizen sus interfaces usando el networking del servidor.
	* :white_check_mark: Consistencia<sub>3.2</sub> : Se puede ver con el funcionamiento que todo se va actualizando, y para uso de locks, como se ha mencionado varias veces, como a nivel de networking todos usan la misma ``InterfazNet``, todos usan los mismos locks para acceder al networking, especificamente se implementaron locks en esta clase para:
		* 1) Enviar Comandos a los clientes
		* 2) Sacar comandos de la cola de comandos del servidor para su posterior ejecucion (Estructura FIFO)
	* :white_check_mark: Logs<sub>3.3</sub>: Se implementaron los logs según lo que indicaba el enunciado, donde se muestra un log cada vez que se añade un comando, y cada vez que se realiza, además de todas las cosas pedidas en el enunciado (Mis logs muestran practicamente todo lo que pasa en el programa :smile: y como se van comunicando y ejecutando las cosas), y además se usa un lock para imprimir logs para que estos no se "solapen" al imprimirse en la consola.

* :white_check_mark: :x: Manejo de Bytes :zero::one::zero::one::one:<sub>5</sub> : Hecha Completa
	* :white_check_mark: Codificación 🐶➡️🈹<sub>5.1</sub> : La codificación está implementada tanto en cliente como en servidor en el archivo ``networking`` en la clase ``Server/ClientNet``, especificamente en el método ``send_bytes`` el cual recibe bytes, y aplica el protocolo de codificación dado en el enunciado, además la serialización misma de los objetos se hace en los métodos ``send_comand`` y ``send_commando_to_all`` los cuales serializan com pickle los comandos que luego se envian a los clientes/servidor según corresponda, siguiendo la logica:
	send_command -> Bytes -> send_bytes -> BytesCodificadosConElProtocolo -> se envian los bytes
	* :white_check_mark: Decodificación 🈹➡️🐶<sub>5.2</sub> : La decodificación se encuentra en la clase ``Server/ClientNet`` en el archivo ``networking.py``, específicamente en el metodo ``recive_data`` el cual se encarga de decodificar los bytes enviados con el protocolo del enunciado, y retorna los bytes originales, que luego son deserializados según corresponde usando pickle, en el ``thread_de_escucha_cliente/servidor``, decodificando el comando mandado.
	* :white_check_mark: Integración<sub>6.1</sub>: Como se dijo antes, tanto en el envió como decodificación se integra el protocolo de envio de mensajes (Que en mi caso estos mensajes siempre son los comandos que se explicaron mas arriba).

* :white_check_mark: Interfaz Grafica<sub>7</sub>: 
	*  :white_check_mark: Modelación <sub>7.1</sub>:  Se hizo una separacion frontend/backend de la interfaz del cliente, donde el frontend solo instancia y actualiza los widgets de la interfaz, y le envia al backend las acciones realizadas en la interfaz, mientras que es el backend el que maneja todos los comandos que llegan al networking del cliente, y envia señales para que se actualizen todos los elementos de la interfaz, asi como también recibe senales del frontend con los widgets de inputs usados, y envia los comandos respectivos al servidor para que este responda y el DCColonos funcione.
	*  :white_check_mark: Sala de Espera<sub>7.2</sub>:  Se actualiza correctamente, y  no deja entrar al servidor en el caso de que ya este lleno, mostrandose un mensaje acorde.
	*  :white_check_mark::x: Sala Juego<sub>7.3</sub>: Se implementa todo lo pedido, excepto que no se pueden comprar caminos, y el botón de sala de espera no redirige a la sala de espera porque no tiene sentido, puesto que no se pueden jugar dos partidas seguidas sin volver a correr el servidor y los clientes.
	*  :white_check_mark: Fin de la partida<sub>7.4</sub>:  Al llegarse a los puntos necesarios para ganar se finaliza la partida y se muestra una ventana que muestra los resultados, notificando si ganó o perdió , y mostrando todos los puntajes de forma ordenada.

* :white_check_mark: Grafo <sub>8</sub>:  El funcionamiento del grafo se encuentra en el servidor en la carpeta ``juego\mapa``, donde se encuentran los archivos ``grafo.json`` y el archivo ``mapa.py``, este útlimo contiene las clases ``Nodo`` que representa los vertices del grafo, la clase ``Hexagono`` que modela los hexagonos y la clase ``Conexion`` que representa las aristas del grafo y los caminos del juego. Todas estas se llaman en la clase ``Mapa``la cual modela todo el mapa del juego.
	*  :white_check_mark: Archivo <sub>7.3</sub> : En el metodo ``cargar_mapa`` de clase mapa se carga el archivo ``grafo.json`` y se instancia todo el mapa, junto con los nodos, hexagonos, numeros de fichas, etc...
	* :white_check_mark: Modelacion <sub>7.3</sub> : Se usan propertys para actualizar todos los datos cuando se carga el mapa, enviando la informacion a todos los usuarios jugando.
	* :white_check_mark: Funcionalidades <sub>7.2</sub> : Si se verifica que se cumplan las restricciones para construir una choza, pero solamente que no haya una choza en un nodo adyacente, porque como se dijo al principio, no se implementaron los caminos. Además, aunque si se puede añadir un camino al mapa a nivel lógico, como no estás implementados, no se muestran en la interfaz. y no se revisan las restricciones de construcción de estos, por último, se encuentra en la clase un método ``carretera_mas_larga`` que calcula el camino mas largo segun los caminos puestos en el mapa usando backtracking, incluso en el ``if __name__ == __main__``de el archivo mapa se muestra un ejemplo instanciando algunos caminos, y el algoritmo funciona, solo que no filtra que sean de un mismo usuario, y como se dijo, no está implementado a nivel gráfico, pero para probar dicho main deben comentarse las lineas de envio de comandos entre otras cosas, pero en el fondo el algoritmo lo que hace es ir avanzando de nodo en nodo contando caminos construidos hasta llegar a un camino que no puede seguir, luego vuelve hacia atras descontando los caminos, hasta que llega a un nodo que aun tenia caminos por recorrer, recorriendo asi todos los caminos que conectan los nodos, una vez que todos fueron visitados, el algoritmo se devuelve hasta el nodo inicial, finalizando el algoritmo y devolviendo los largos de los caminos desde el nodo inicial, iterando sobre todos los nodos y sacando el máximo, se encuentra efectivamente la carretera mas larga.

* :white_check_mark: :x: Reglas DCColonos <sub>7.3</sub> : Se cumplen todas las reglas, pero no las que involucran caminos, puesto que estos no se implementan.
	* :white_check_mark: Inicio Juego <sub>7.3</sub> : Hecho completo pero sin caminos.
	*  :white_check_mark: lanzamiento de Dados <sub>7.3</sub> : Hecho completo incluido con el 7 el cual bota materias primas aleatorias y lo notifica a los jugadores, los dados se actualizan en todas las interfaces y se reparten las materias primas
	* :white_check_mark: :x: Turno <sub>7.3</sub> : Se hace todo menos la carretera mas larga, la implementación del punto de victoria se encuentra en el servidor en ``juego\juego.py`` donde se llama a la funcion ``comprar_carta_desarrollo`` cuando el jugador de turno apreta el boton de carta de desarrollo, este le envia al banco la acción para validar la compra y el banco de la clase ``Banco`` en el archivo ``banco.py`` de la carpeta ``entidades`` en el metodo ``comprar_carta_desarrollo`` valida el precio y usa el archivo entregado en el enunciado para sacar una carta de desarrollo, y instanciar la carta pedida, esta instancia de carta la retorna al juego quien la activa inmediatamente y muestra un ``Qdialog`` en la interfaz para notificar o realizar la acción que ocurre (Ya sea punto de victoria o Monopolio), esta acción además se notifica a todos los jugadores. 
	* :white_check_mark: Termino del juego<sub>7.3</sub> : Hecho completo
* :white_check_mark: General <sub>7.3</sub> : Hecho completo
	* :white_check_mark: Parametros <sub>7.3</sub> : Se tiene un  archivo de parametros para cada programa (Cliente y Servidor) y se llaman usando json cuando se necesitan.
	* :white_check_mark: Grafo <sub>7.3</sub> : Se utiliza y carga en el metodo ``cargar_mapa`` ya mencionado de la clase ``Mapa``
	* :white_check_mark: Generador de mazos <sub>7.3</sub> : Se usa el metodo ``sacar_cartas`` en la clase ``Banco`` cuando se quiere comprar una carta de desarrollo como se explicó antes.
* :white_check_mark: Bonus <sub>7.3</sub> : Se implementa el bonus de ladron (Que tiene la cara del profe 👺
## Ejecución :computer:
El módulo principal de la tarea a ejecutar es  ```main.py```. Además se debe crear los siguientes archivos y directorios adicionales:
1.  Carpeta ```sprites``` en ```T02``` que deben ser los mismos sprites que se subieron en el syllabus
2. Carpeta ``songs`` en ``T02`` que debe contener ambas canciones al igual como estaban en el syllabus

## Librerías :books:
### Librerías externas utilizadas
Las librerías externas utilizadas fueron ``PyQt5``, y el resto fueron solo librerias internas como

1. ```random```

### Librerías propias
Por otro lado, los módulos que fueron creados fueron los siguientes:

* Carpeta ``backend``

1. ```back_inicio```: contiene ``BackInicio`` que se encarga de la logica tras la ventana de inicio
2. ```back_juego```: contiene ``BackJuego`` que se encarga de la logica tras la ventana de juego, ya sea del manejo de entradas de usuario como de la ronda en funcionamiento a traves de su atributo ``ronda`` 
3. ``back_ranking`` : contiene ``BackRanking`` que tiene los metodos ``ordenar_puntaje`` que ordena los puntajes del archivo ``ranking.txt`` y el metodo ``escribir_puntaje`` que escribe un nuevo puntaje en el archivo ``ranking.txt``
* Carpeta ``frontend``
4. ``front_inicio`` : contiene ``VentanaInicio`` la cual corresponde al frontend de la ventana de inicio y envia todas las señales al backend de botones apretados entradas de texto, etc.
5.  ``front_juego`` : contiene ``VentanaJuego`` que corresponde al frontend del juego y se encarga de enviar todas las entradas de usuario como botones presionados, teclas presionadas etc. al backend del juego.
6. ``front_ranking`` : contiene ``VentanaRanking``que crea la ventana de ranking y envia las señales correspondientes cuando se abre la ventana y cuando se cierra.
7. ``front_resumen``: contiene ``VentanaResumen`` que se encarga del frontend y GUI de la ventana de resumen, y envia las señales correspondientes cuando se presiona el botón volver en caso de que haya que ir a la ventana de inicio o de juego.
* Carpeta ``entidades``
8. ``flechas``: Contiene ``Flecha(QLabel)`` la cual es la clase padre de  ``FlechaNormal``, ``FlechaDorada``, ``FlechaX2`` y ``FlechaHielo`` las cuales modelan las distintas flechas y deben estar contenidas por composicion en una instancia de la clase ``Paso(QTimer)``.
9. ``pasos``: Contiene ``Paso`` que modela los diferentes tipos de pasos ya sean normales o combinados, y que contiene a las flechas del paso, estas son todas del mismo tipo para un mismo paso. Además el modulo contiene a la clase  ``GeneradorPasos(QTimer)`` la cual es un objeto que es capaz de generar pasos a una velocidad ``TIEMPO_ENTRE_PASOS`` y dependiendo de la dificultad entre otras cosas va generando los pasos segun la probabilidad de cada tipo de flecha.
10. ``pinguinos`` : contiene a la clase ``Pinguino(QLabel)`` la cual modela al pinguino ya sea los de la tienda o los introducidos en la pista de baile.
* Carpeta principal ``T02``
11. ``ronda``: Contiene a la clase ``Ronda`` la cual se encarga de hacer funcionar todas las cosas internas de cada ronda como la revisión de los pasos, los calculos de estadisticas, los manejos de los combos, los pasos generados, los pasos correctos, incorrectos, en fin, todo lo interno al juego de las flechas en si.

## Supuestos y consideraciones adicionales :thinking:
Los supuestos que realicé durante la tarea son los siguientes:

1. El jugador no entrará y saldrá de la ventana de inicio y volverá al juego de manera tan rápida
2. El jugador debe apretar y soltar las teclas para que estas sean procesadas, puesto que solo apretar las teclas no se considera como una acción puesto que nunca se presionaran exactamente al mismo tiempo, por lo que se deben presionar todas y luego ser soltada al menos una para que se envien las teclas, esto como se ve simula muy bien el "al mismo tiempo" de las teclas.
3. No se tratarán de modificar los tamaños de las ventanas, y el usuario tendrá un monitor lo suficientemente grande para que estas quepan
4. El jugador cambiara la ``TASA_DE_REFRESCO`` dependiendo de las caracteristicas de su computador para que este funcione de manera correcta al igual que en otros juegos se puede subir y bajar la calidad grafica de los juegos.
5. Si se realiza la acción de pausa desde el boton se reanudara desde el botón y si se hace como cheatcode (presionando la P) se reanudara usando el mismo cheatcode.
6. Las teclas que se pueden modificar en los parametros siempre serán caracteres, puesto que no se pueden poner las "flechitas" como string en los parametros y los codigos de las teclas no son lo suficientemente "intuitivos" ni universales para usarlos como parámetro a diferencia de los caracteres.
7. La intersección de los pinguinos esta dada por el sprite del pinguino y no por la parte del pinguino en si, por lo que para que esten mas pegados el sprite del pinguino deberia estar mejor recortado.


## Referencias de código externo :book:

Para realizar mi tarea vi codigo de algunas partes pero este fue modificado, esta fue de :
1. https://stackoverflow.com/questions/7176951/how-to-get-multiple-key-presses-in-single-event el cual daba una idea de como manejar multples teclas, pero luego fue modificado para uso propio.
2. El resto hice casi pura lectura de la documentación oficial de PyQt5, ya sea la de python o la de C++, que se encuentra en:
https://doc.qt.io/qtforpython/