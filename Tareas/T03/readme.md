

# Tarea 03: DCColonos

## Consideraciones generales 

El programa logra hacer la mayoria de las cosas pedidas, se implementa casi todo, pero no se implementaron los caminos a nivel grafico, y faltan un par de cosas de los caminos a nivel logico (Se explica mas adelante con mas detalle), el juego corre una partida de manera correcta, pero el servidor no es capaz de jugar una segunda partida seguida sin cerrar los clientes anteriores y volviendo a correr el archivo main del servidor, por lo que para probar todos los funcionamientos se puede ajustar como quiera los parametros, y jugar con tranquilidad una partida completa, pero para probar distintas partidas se debe volver a correr el servidor y los clientes. Por otro lado, explicando brevemente el funcionamiento cliente servidor, el servidor y el cliente tienen una clase Server que se encuentra en ``networking.py`` y es la encargada de realizar las serializaciones, recibir y intercambiar informacion a traves de los sockets cliente-servidor, asi, todo el flujo de datos pasa por esta clase, pero adem치s hay otra clase en el mismo archivo que se llama ``Interfaz{Server/Client}Net``, que es la que se encarga de "Acceder" a dicho networking tanto del cliente como del servidor que intercambia la informaci칩n, esto significa que usa locks para entrar en laz "zonas criticas" como lectura de comandos que se acumulan en el servidor, o envio de comandos a traves del socket del servidor, para evitar concurrencia en el programa y lograr la correcta ejecuci칩n cronologica de todos los comandos y operaciones a realizar tanto en el cliente como en el servidor. As칤, esta interfaz se instancia en el mismo archivo y es importada en las diferentes partes del codigo que necesiten "enviar o recibir algo", y como todas lo hacen a traves de esta misma interfaz (Que no debe confundirse con una interfaz gr치fica, sino que es una interfaz de acceso al networking del servidor o del cliente) no existe concurrencia aunque varias clases, entidades, o Threads distintos quieran usar el networking del programa. Por ultimo, para la mayor칤a de las implementaciones de las distintas reglas del DCColonos, el flujo es el siguiente
Instancia_que_manda_o_lee_algo  -> InterfazServerNet -> ServerNet -> Se serializa y envia la informacion -> ClientNet -> InterfazClientNet -> BackCliente -> FrontCliente.
Es decir, se va pasando por diferentes capas de abstracci칩n para lograr implementar cosas nuevas de manera sencilla y sin concurrencia a traves de comandos, pero esta realizaci칩n por pasos logra evitar concurrencia y simplificar la codificaci칩n y mantenci칩n del programa.

### Cosas implementadas y no implementadas :white_check_mark: :x:

* :white_check_mark: :x:Networking<sub>1</sub>: Hecha casi completa.
En el archivo ``networking.py`` ubicado en la carpeta ``backend``, y en el archivo ``networking.py`` ubicando en la carpeta ``server`` se encuentra todo lo referente al networking de ambos programas (Cliente y servidor), donde como se explico antes, existe una clase Server/ClientNet que se encarga del manejo de sockets, threads de aceptar clientes, threads, de escucha, serializaci칩n, envio de bytes, de comandos, etc..., y tambien est치 la ``Interfaz(Cliente/Server)Net`` que sirve de acceso a este networking de manera no concurrente a traves de locks. Adem치s se instancian ambas clases en el mismo archivo para poder ser importada la interfaz del networking y comprartirla en las diferentes partes del programa
	* :white_check_mark: Protocolo<sub>1.1</sub>:  En el ``__init__`` del servidor y del cliente se instancia el socket usando el protocolo TCP/IP usando los parametros dados en ``Parametros.json`` en el host y el port (Se testio el programa usando de host el nombre del equipo, y el puerto 200, y en una red LAN, usando diferentes computadores conectados a un mismo router).
	* :white_check_mark: Correcto uso de sockets<sub>1.2</sub>: Los sockets se instancian como se dijo antes en el ``__init__`` de las clases de Networking, y ademas se tienen try/excpet/finally para lograr siempre cerrar los sockets en caso de cualquier error. En el caso del servidor, este se pone a escuchar segun el ``host`` y ``port`` pasado en los ``parametros.json`` con el metodo ``encender`` el cual llama a ``bind_and_listen`` y logra conectar y poner a escuchar el server, y corre un thread de aceptar clientes. Por otro lado en el caso de los clientes, se llama a ``encender `` el cual llama al m칠todo ``connect`` que conecta el socket al servidor y inicializa los threads que escuchan el servidor, y el thread que revisa los comandos que van llegando  a la cola del servidor.
	Tambi칠n se logra trabajar la aplicacion concurrentemente, pues se implementaron threads de escucha a cada clietne por separado en el servidor. Y tambi칠n para evitar concurrencia se hizo una estructura en cada networking para ir recibiendo "comandos" que se explicar치n a continuaci칩n, pero estos van llegando a una cola del servidor con estructura de datos FIFO, y a trav칠s de locks, estos se van leyendo de uno en uno tanto en el cliente como en el servidor, lo que asegura una correcta secuancia en la realizaci칩n de comandos, y evita errores inesperador por concurrencia.
	*  :white_check_mark: Conexi칩n<sub>2.1</sub> : Como se puede apreciar en el funcionamiento del programa, la conexi칩n es sostenida en el tiempo, pero me gustar칤a aclarar aqu칤 como funcionan estos "comandos" que se envian entre cliente y servidor. Estos son instancias de la clase ``Comando``, definida en el archivo ``comando.py`` , y son los mensajes que se envian a trav칠s de los sockets, estos contienen un string que indica la instrucci칩n a realizar, y en caso de ser necesarios, los parametros para realizar dicha acci칩n, a modo de ejemplo podemos decir que si el servidor debe realizar la acci칩n suma, el cliente envia un comando de la forma ``Comando("add", 5, 4, 9)`` donde el servidor a usando la interfaz para el networking, y accediendo a la cola del servidor donde se van a  acumular estos comandos, logra sacar el comando de la cola, y ejecutarlo en la parte donde se corre dicho comando, por lo mismo, los strings para los comandos son unicos, y estan escritos en ingl칠s, a modo de ID 칰nico para no tener problemas con las distintas partes del programa. As칤 diferentes clases del programa tienen diferentes diccionarios de comandos de la forma ``{"nombre_comando": metodo}``, linkeando cada comando al metodo especial a ejecutar, esto entonces abstrae la forma de implementar cosas nuevas para tener un funcionamiento general mas f치cil de manejar y menos concurrente, y permite a침adir nuevas funcionalidades sin afectar las ya implementadas.
	*  :white_check_mark: :x: Manejo de clientes<sub>2.2</sub> : En el caso del manejo de los clientes por el servidor, se pueden conectar varios y desconectar sin afectar el funcionamiento del servidor, esto se ejemplifica de mejor manera en la sala de espera, donde se pueden conectar y desconectar clientes, hasta que se llene la sala y ahi reci칠n parte el juego. Por otro lado, por temas de implementaci칩n, los clientes cuando ya se est치 dentro de una partida, no se pueden desconectar, pues la partida aun estara "esperando" algunas de sus acciones, pero no se cae el programa cuando este se desconecta. Por 칰ltimo, la caida inesperada del servidor no se manejar de manera correcta, solamente esta el caso de que si un cliente se conecta, y el servidor esta "caido", se muestra en consola que el servidor no esta disponible manejando el error de conexion.
*  :white_check_mark: Arquitectura Cliente Servidor sub>3</sub>: Hecha completa, los roles est치n claramente separados, de hecho, ninguna de las clases logicas del juego (Por ejemplo ``Mapa``, ``Usuario`` , ``Banco``, entre otras) no estan contenidas en el programa de cliente, todo se envia al servidor, y este maneja todos los datos a nivel logico en las diferentes clases del juego. Luego de procesada la informaci칩n se env칤a solo lo necesario para actualizar la interfas de el/Los clientes seg칰n corresponda, esto se hace usando los metodos de la interfaz de networking ``send_command`` y ``send_command_to_all`` que envian comandos a uno o varios clientes respectivamente. Un buen ejemplo es cuando se tiran los dados, donde el cliente notifica al servidor que apret칩 el bot칩n, los dados se tiran a nivel l칩gico en la clase ``Juego``, ``lanzar_dados`` del archivo ``juego.py``, y estos numeros de dados son enviados a las interfaces de todos los clientes usando la linea ``interfaz_network.send_command_to_all("update_dices", dado_1, dado_2)``, es decir solo se envian los numeros que se deben mostrar en la interfaz al backend del cliente, que posteriormente envia una senal al frontend del cliente para actualizar los dados, (Es una especie de burocracia, pero mantiene los Roles bien separados).
	* :white_check_mark: Roles<sub>3.1</sub> : A nivel espec칤fico de roles, el servidor contiene toda la logica del juego, en todos los archivos que estan contenidos en la carpeta ``juego``, lo que incluye generaci칩n del mapa, robo de cartas, lanzamiento de dados, validaci칩n de costos de compras, validaci칩n de construcciones en el mapa, entre muchas otras cosas. Mientras que por otro lado, el cliente solo tiene funcionamiento l칩gico/gr치fico (Osea lo que no es networking) como backend  en la carpeta ``backend`` y frontend en la carpeta ``frontend``, los cuales se encargan en primer lugar de habilitar o bloquear los widgets de Input del usuario seg칰n se lo envie el servidor (pues este maneja los turnos), en segundo lugar, de actualizar la informaci칩n que se muestra en la interfaz del jugador seg칰n, los datos que valla enviando el servidor (Ejemplo claro de ello son cuando se cargan las materias primas y los numeros de fichas en la interfaz, seg칰n los datos que manda el servidor cuando carga el mapa). Adem치s como ejemplo de validaci칩n se tiene cuando se compran casas o cartas de desarrollo, donde a trav칠s del ``Banco`` se validan y notifican las compras, y a trav칠s del ``Mapa`` se validan las adyacencias de construcciones. Por 칰ltimo, en la parte de "Almacenar y actualizar", se hicieron propertys para todas las clases del juego, cosa que cada vez que alguien gane un punto, construya algo, gane materias primas, entre otras cosas, esta informaci칩n se envia a todos los usuarios para que se actulizen sus interfaces usando el networking del servidor.
	* :white_check_mark: Consistencia<sub>3.2</sub> : Se puede ver con el funcionamiento que todo se va actualizando, y para uso de locks, como se ha mencionado varias veces, como a nivel de networking todos usan la misma ``InterfazNet``, todos usan los mismos locks para acceder al networking, especificamente se implementaron locks en esta clase para:
		* 1) Enviar Comandos a los clientes
		* 2) Sacar comandos de la cola de comandos del servidor para su posterior ejecucion (Estructura FIFO)
	* :white_check_mark: Logs<sub>3.3</sub>: Se implementaron los logs seg칰n lo que indicaba el enunciado, donde se muestra un log cada vez que se a침ade un comando, y cada vez que se realiza, adem치s de todas las cosas pedidas en el enunciado (Mis logs muestran practicamente todo lo que pasa en el programa :smile: y como se van comunicando y ejecutando las cosas), y adem치s se usa un lock para imprimir logs para que estos no se "solapen" al imprimirse en la consola.

* :white_check_mark: :x: Manejo de Bytes :zero::one::zero::one::one:<sub>5</sub> : Hecha Completa
	* :white_check_mark: Codificaci칩n 游냤俱뫮잺游걏<sub>5.1</sub> : La codificaci칩n est치 implementada tanto en cliente como en servidor en el archivo ``networking`` en la clase ``Server/ClientNet``, especificamente en el m칠todo ``send_bytes`` el cual recibe bytes, y aplica el protocolo de codificaci칩n dado en el enunciado, adem치s la serializaci칩n misma de los objetos se hace en los m칠todos ``send_comand`` y ``send_commando_to_all`` los cuales serializan com pickle los comandos que luego se envian a los clientes/servidor seg칰n corresponda, siguiendo la logica:
	send_command -> Bytes -> send_bytes -> BytesCodificadosConElProtocolo -> se envian los bytes
	* :white_check_mark: Decodificaci칩n 游걏俱뫮잺游냤<sub>5.2</sub> : La decodificaci칩n se encuentra en la clase ``Server/ClientNet`` en el archivo ``networking.py``, espec칤ficamente en el metodo ``recive_data`` el cual se encarga de decodificar los bytes enviados con el protocolo del enunciado, y retorna los bytes originales, que luego son deserializados seg칰n corresponde usando pickle, en el ``thread_de_escucha_cliente/servidor``, decodificando el comando mandado.
	* :white_check_mark: Integraci칩n<sub>6.1</sub>: Como se dijo antes, tanto en el envi칩 como decodificaci칩n se integra el protocolo de envio de mensajes (Que en mi caso estos mensajes siempre son los comandos que se explicaron mas arriba).

* :white_check_mark: Interfaz Grafica<sub>7</sub>: 
	*  :white_check_mark: Modelaci칩n <sub>7.1</sub>:  Se hizo una separacion frontend/backend de la interfaz del cliente, donde el frontend solo instancia y actualiza los widgets de la interfaz, y le envia al backend las acciones realizadas en la interfaz, mientras que es el backend el que maneja todos los comandos que llegan al networking del cliente, y envia se침ales para que se actualizen todos los elementos de la interfaz, asi como tambi칠n recibe senales del frontend con los widgets de inputs usados, y envia los comandos respectivos al servidor para que este responda y el DCColonos funcione.
	*  :white_check_mark: Sala de Espera<sub>7.2</sub>:  Se actualiza correctamente, y  no deja entrar al servidor en el caso de que ya este lleno, mostrandose un mensaje acorde.
	*  :white_check_mark::x: Sala Juego<sub>7.3</sub>: Se implementa todo lo pedido, excepto que no se pueden comprar caminos, y el bot칩n de sala de espera no redirige a la sala de espera porque no tiene sentido, puesto que no se pueden jugar dos partidas seguidas sin volver a correr el servidor y los clientes.
	*  :white_check_mark: Fin de la partida<sub>7.4</sub>:  Al llegarse a los puntos necesarios para ganar se finaliza la partida y se muestra una ventana que muestra los resultados, notificando si gan칩 o perdi칩 , y mostrando todos los puntajes de forma ordenada.

* :white_check_mark: Grafo <sub>8</sub>:  El funcionamiento del grafo se encuentra en el servidor en la carpeta ``juego\mapa``, donde se encuentran los archivos ``grafo.json`` y el archivo ``mapa.py``, este 칰tlimo contiene las clases ``Nodo`` que representa los vertices del grafo, la clase ``Hexagono`` que modela los hexagonos y la clase ``Conexion`` que representa las aristas del grafo y los caminos del juego. Todas estas se llaman en la clase ``Mapa``la cual modela todo el mapa del juego.
	*  :white_check_mark: Archivo <sub>7.3</sub> : En el metodo ``cargar_mapa`` de clase mapa se carga el archivo ``grafo.json`` y se instancia todo el mapa, junto con los nodos, hexagonos, numeros de fichas, etc...
	* :white_check_mark: Modelacion <sub>7.3</sub> : Se usan propertys para actualizar todos los datos cuando se carga el mapa, enviando la informacion a todos los usuarios jugando.
	* :white_check_mark: Funcionalidades <sub>7.2</sub> : Si se verifica que se cumplan las restricciones para construir una choza, pero solamente que no haya una choza en un nodo adyacente, porque como se dijo al principio, no se implementaron los caminos. Adem치s, aunque si se puede a침adir un camino al mapa a nivel l칩gico, como no est치s implementados, no se muestran en la interfaz. y no se revisan las restricciones de construcci칩n de estos, por 칰ltimo, se encuentra en la clase un m칠todo ``carretera_mas_larga`` que calcula el camino mas largo segun los caminos puestos en el mapa usando backtracking, incluso en el ``if __name__ == __main__``de el archivo mapa se muestra un ejemplo instanciando algunos caminos, y el algoritmo funciona, solo que no filtra que sean de un mismo usuario, y como se dijo, no est치 implementado a nivel gr치fico, pero para probar dicho main deben comentarse las lineas de envio de comandos entre otras cosas, pero en el fondo el algoritmo lo que hace es ir avanzando de nodo en nodo contando caminos construidos hasta llegar a un camino que no puede seguir, luego vuelve hacia atras descontando los caminos, hasta que llega a un nodo que aun tenia caminos por recorrer, recorriendo asi todos los caminos que conectan los nodos, una vez que todos fueron visitados, el algoritmo se devuelve hasta el nodo inicial, finalizando el algoritmo y devolviendo los largos de los caminos desde el nodo inicial, iterando sobre todos los nodos y sacando el m치ximo, se encuentra efectivamente la carretera mas larga.

* :white_check_mark: :x: Reglas DCColonos <sub>7.3</sub> : Se cumplen todas las reglas, pero no las que involucran caminos, puesto que estos no se implementan.
	* :white_check_mark: Inicio Juego <sub>7.3</sub> : Hecho completo pero sin caminos.
	*  :white_check_mark: lanzamiento de Dados <sub>7.3</sub> : Hecho completo incluido con el 7 el cual bota materias primas aleatorias y lo notifica a los jugadores, los dados se actualizan en todas las interfaces y se reparten las materias primas
	* :white_check_mark: :x: Turno <sub>7.3</sub> : Se hace todo menos la carretera mas larga, la implementaci칩n del punto de victoria se encuentra en el servidor en ``juego\juego.py`` donde se llama a la funcion ``comprar_carta_desarrollo`` cuando el jugador de turno apreta el boton de carta de desarrollo, este le envia al banco la acci칩n para validar la compra y el banco de la clase ``Banco`` en el archivo ``banco.py`` de la carpeta ``entidades`` en el metodo ``comprar_carta_desarrollo`` valida el precio y usa el archivo entregado en el enunciado para sacar una carta de desarrollo, y instanciar la carta pedida, esta instancia de carta la retorna al juego quien la activa inmediatamente y muestra un ``Qdialog`` en la interfaz para notificar o realizar la acci칩n que ocurre (Ya sea punto de victoria o Monopolio), esta acci칩n adem치s se notifica a todos los jugadores. 
	* :white_check_mark: Termino del juego<sub>7.3</sub> : Hecho completo
* :white_check_mark: General <sub>7.3</sub> : Hecho completo
	* :white_check_mark: Parametros <sub>7.3</sub> : Se tiene un  archivo de parametros para cada programa (Cliente y Servidor) y se llaman usando json cuando se necesitan.
	* :white_check_mark: Grafo <sub>7.3</sub> : Se utiliza y carga en el metodo ``cargar_mapa`` ya mencionado de la clase ``Mapa``
	* :white_check_mark: Generador de mazos <sub>7.3</sub> : Se usa el metodo ``sacar_cartas`` en la clase ``Banco`` cuando se quiere comprar una carta de desarrollo como se explic칩 antes.
* :white_check_mark: Bonus <sub>7.3</sub> : Se implementa el bonus de ladron (Que tiene la cara del profe 游놐
## Ejecuci칩n :computer:
El m칩dulo principal de la tarea a ejecutar es  ```main.py```. Adem치s se debe crear los siguientes archivos y directorios adicionales:
1.  Carpeta ```sprites``` en ```T02``` que deben ser los mismos sprites que se subieron en el syllabus
2. Carpeta ``songs`` en ``T02`` que debe contener ambas canciones al igual como estaban en el syllabus

## Librer칤as :books:
### Librer칤as externas utilizadas
Las librer칤as externas utilizadas fueron ``PyQt5``, y el resto fueron solo librerias internas como

1. ```random```

### Librer칤as propias
Por otro lado, los m칩dulos que fueron creados fueron los siguientes:

* Carpeta ``backend``

1. ```back_inicio```: contiene ``BackInicio`` que se encarga de la logica tras la ventana de inicio
2. ```back_juego```: contiene ``BackJuego`` que se encarga de la logica tras la ventana de juego, ya sea del manejo de entradas de usuario como de la ronda en funcionamiento a traves de su atributo ``ronda`` 
3. ``back_ranking`` : contiene ``BackRanking`` que tiene los metodos ``ordenar_puntaje`` que ordena los puntajes del archivo ``ranking.txt`` y el metodo ``escribir_puntaje`` que escribe un nuevo puntaje en el archivo ``ranking.txt``
* Carpeta ``frontend``
4. ``front_inicio`` : contiene ``VentanaInicio`` la cual corresponde al frontend de la ventana de inicio y envia todas las se침ales al backend de botones apretados entradas de texto, etc.
5.  ``front_juego`` : contiene ``VentanaJuego`` que corresponde al frontend del juego y se encarga de enviar todas las entradas de usuario como botones presionados, teclas presionadas etc. al backend del juego.
6. ``front_ranking`` : contiene ``VentanaRanking``que crea la ventana de ranking y envia las se침ales correspondientes cuando se abre la ventana y cuando se cierra.
7. ``front_resumen``: contiene ``VentanaResumen`` que se encarga del frontend y GUI de la ventana de resumen, y envia las se침ales correspondientes cuando se presiona el bot칩n volver en caso de que haya que ir a la ventana de inicio o de juego.
* Carpeta ``entidades``
8. ``flechas``: Contiene ``Flecha(QLabel)`` la cual es la clase padre de  ``FlechaNormal``, ``FlechaDorada``, ``FlechaX2`` y ``FlechaHielo`` las cuales modelan las distintas flechas y deben estar contenidas por composicion en una instancia de la clase ``Paso(QTimer)``.
9. ``pasos``: Contiene ``Paso`` que modela los diferentes tipos de pasos ya sean normales o combinados, y que contiene a las flechas del paso, estas son todas del mismo tipo para un mismo paso. Adem치s el modulo contiene a la clase  ``GeneradorPasos(QTimer)`` la cual es un objeto que es capaz de generar pasos a una velocidad ``TIEMPO_ENTRE_PASOS`` y dependiendo de la dificultad entre otras cosas va generando los pasos segun la probabilidad de cada tipo de flecha.
10. ``pinguinos`` : contiene a la clase ``Pinguino(QLabel)`` la cual modela al pinguino ya sea los de la tienda o los introducidos en la pista de baile.
* Carpeta principal ``T02``
11. ``ronda``: Contiene a la clase ``Ronda`` la cual se encarga de hacer funcionar todas las cosas internas de cada ronda como la revisi칩n de los pasos, los calculos de estadisticas, los manejos de los combos, los pasos generados, los pasos correctos, incorrectos, en fin, todo lo interno al juego de las flechas en si.

## Supuestos y consideraciones adicionales :thinking:
Los supuestos que realic칠 durante la tarea son los siguientes:

1. El jugador no entrar치 y saldr치 de la ventana de inicio y volver치 al juego de manera tan r치pida
2. El jugador debe apretar y soltar las teclas para que estas sean procesadas, puesto que solo apretar las teclas no se considera como una acci칩n puesto que nunca se presionaran exactamente al mismo tiempo, por lo que se deben presionar todas y luego ser soltada al menos una para que se envien las teclas, esto como se ve simula muy bien el "al mismo tiempo" de las teclas.
3. No se tratar치n de modificar los tama침os de las ventanas, y el usuario tendr치 un monitor lo suficientemente grande para que estas quepan
4. El jugador cambiara la ``TASA_DE_REFRESCO`` dependiendo de las caracteristicas de su computador para que este funcione de manera correcta al igual que en otros juegos se puede subir y bajar la calidad grafica de los juegos.
5. Si se realiza la acci칩n de pausa desde el boton se reanudara desde el bot칩n y si se hace como cheatcode (presionando la P) se reanudara usando el mismo cheatcode.
6. Las teclas que se pueden modificar en los parametros siempre ser치n caracteres, puesto que no se pueden poner las "flechitas" como string en los parametros y los codigos de las teclas no son lo suficientemente "intuitivos" ni universales para usarlos como par치metro a diferencia de los caracteres.
7. La intersecci칩n de los pinguinos esta dada por el sprite del pinguino y no por la parte del pinguino en si, por lo que para que esten mas pegados el sprite del pinguino deberia estar mejor recortado.


## Referencias de c칩digo externo :book:

Para realizar mi tarea vi codigo de algunas partes pero este fue modificado, esta fue de :
1. https://stackoverflow.com/questions/7176951/how-to-get-multiple-key-presses-in-single-event el cual daba una idea de como manejar multples teclas, pero luego fue modificado para uso propio.
2. El resto hice casi pura lectura de la documentaci칩n oficial de PyQt5, ya sea la de python o la de C++, que se encuentra en:
https://doc.qt.io/qtforpython/