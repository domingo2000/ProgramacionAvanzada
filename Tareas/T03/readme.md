

# Tarea 03: DCColonos

## Consideraciones generales 

El programa logra hacer la mayoria de las cosas pedidas, se implementa casi todo, pero no se implementaron los caminos a nivel grafico, y faltan un par de cosas de los caminos a nivel logico (Se explica mas adelante con mas detalle), el juego corre una partida de manera correcta, pero el servidor no es capaz de jugar una segunda partida seguida sin cerrar los clientes anteriores y volviendo a correr el archivo main del servidor, por lo que para probar todos los funcionamientos se puede ajustar como quiera los parametros, y jugar con tranquilidad una partida completa, pero para probar distintas partidas se debe volver a correr el servidor y los clientes. Por otro lado, explicando brevemente el funcionamiento cliente servidor, el servidor y el cliente tienen una clase Server que se encuentra en ``networking.py`` y es la encargada de realizar las serializaciones, recibir y intercambiar informacion a traves de los sockets cliente-servidor, asi, todo el flujo de datos pasa por esta clase, pero además hay otra clase en el mismo archivo que se llama ``Interfaz{Server/Client}Net``, que es la que se encarga de "Acceder" a dicho networking tanto del cliente como del servidor que intercambia la información, esto significa que usa locks para entrar en laz "zonas criticas" como lectura de comandos que se acumulan en el servidor, o envio de comandos a traves del socket del servidor, para evitar concurrencia en el programa y lograr la correcta ejecución cronologica de todos los comandos y operaciones a realizar tanto en el cliente como en el servidor. Así, esta interfaz se instancia en el mismo archivo y es importada en las diferentes partes del codigo que necesiten "enviar o recibir algo", y como todas lo hacen a traves de esta misma interfaz (Que no debe confundirse con una interfaz gráfica, sino que es una interfaz de acceso al networking del servidor o del cliente) no existe concurrencia aunque varias clases, entidades, o Threads distintos quieran usar el networking del programa. Por ultimo, para la mayoría de las implementaciones de las distintas reglas del DCColonos, el flujo es el siguiente
Instancia_que_manda_o_lee_algo  -> InterfazServerNet -> ServerNet -> Se serializa y envia la informacion -> ClientNet -> InterfazClientNet -> BackCliente -> FrontCliente.
Es decir, se va pasando por diferentes capas de abstracción para lograr implementar cosas nuevas de manera sencilla y sin concurrencia a traves de comandos, pero esta realización por pasos logra evitar concurrencia y simplificar la codificación y mantención del programa.

### Cosas implementadas y no implementadas :white_check_mark: :x:

* :white_check_mark: :x:Networking<sub>1</sub>: Hecha casi completa.
En el archivo ``networking.py`` ubicado en la carpeta ``backend``, y en el archivo ``networking.py`` ubicando en la carpeta ``server`` se encuentra todo lo referente al networking de ambos programas (Cliente y servidor), donde como se explico antes, existe una clase Server/ClientNet que se encarga del manejo de sockets, threads de aceptar clientes, threads, de escucha, serialización, envio de bytes, de comandos, etc..., y tambien está la ``Interfaz(Cliente/Server)Net`` que sirve de acceso a este networking de manera no concurrente a traves de locks. Además se instancian ambas clases en el mismo archivo para poder ser importada la interfaz del networking y comprartirla en las diferentes partes del programa
	* :white_check_mark: Protocolo<sub>1.1</sub>:  En el ``__init__`` del servidor y del cliente se instancia el socket usando el protocolo TCP/IP usando los parametros dados en ``Parametros.json`` en el host y el port (Se testio el programa usando de host el nombre del equipo, y el puerto 200, y en una red LAN, usando diferentes computadores conectados a un mismo router).
	* :white_check_mark: Correcto uso de sockets<sub>1.2</sub>: Los sockets se instancian como se dijo antes en el ``__init__`` de las clases de Networking, y ademas se tienen try/excpet/finally para lograr siempre cerrar los sockets en caso de cualquier error. En el caso del servidor, este se pone a escuchar segun el ``host`` y ``port`` pasado en los ``parametros.json`` con el metodo ``encender`` el cual llama a ``bind_and_listen`` y logra conectar y poner a escuchar el server, y corre un thread de aceptar clientes. Por otro lado en el caso de los clientes, se llama a ``encender `` el cual llama al método ``connect`` que conecta el socket al servidor y inicializa los threads que escuchan el servidor, y el thread que revisa los comandos que van llegando  a la cola del servidor.
	También se logra trabajar la aplicacion concurrentemente, pues se implementaron threads de escucha a cada clietne por separado en el servidor. Y también para evitar concurrencia se hizo una estructura en cada networking para ir recibiendo "comandos" que se explicarán a continuación, pero estos van llegando a una cola del servidor con estructura de datos FIFO, y a través de locks, estos se van leyendo de uno en uno tanto en el cliente como en el servidor, lo que asegura una correcta secuancia en la realización de comandos, y evita errores inesperador por concurrencia.
	*  :white_check_mark: Conexión<sub>1.3</sub> : Como se puede apreciar en el funcionamiento del programa, la conexión es sostenida en el tiempo, pero me gustaría aclarar aquí como funcionan estos "comandos" que se envian entre cliente y servidor. Estos son instancias de la clase ``Comando``, definida en el archivo ``comando.py`` , y son los mensajes que se envian a través de los sockets, estos contienen un string que indica la instrucción a realizar, y en caso de ser necesarios, los parametros para realizar dicha acción, a modo de ejemplo podemos decir que si el servidor debe realizar la acción suma, el cliente envia un comando de la forma ``Comando("add", 5, 4, 9)`` donde el servidor a usando la interfaz para el networking, y accediendo a la cola del servidor donde se van a  acumular estos comandos, logra sacar el comando de la cola, y ejecutarlo en la parte donde se corre dicho comando, por lo mismo, los strings para los comandos son unicos, y estan escritos en inglés, a modo de ID único para no tener problemas con las distintas partes del programa. Así diferentes clases del programa tienen diferentes diccionarios de comandos de la forma ``{"nombre_comando": metodo}``, linkeando cada comando al metodo especial a ejecutar, esto entonces abstrae la forma de implementar cosas nuevas para tener un funcionamiento general mas fácil de manejar y menos concurrente, y permite añadir nuevas funcionalidades sin afectar las ya implementadas.
	*  :white_check_mark: :x: Manejo de clientes<sub>1.4</sub> : En el caso del manejo de los clientes por el servidor, se pueden conectar varios y desconectar sin afectar el funcionamiento del servidor, esto se ejemplifica de mejor manera en la sala de espera, donde se pueden conectar y desconectar clientes, hasta que se llene la sala y ahi recién parte el juego. Por otro lado, por temas de implementación, los clientes cuando ya se está dentro de una partida, no se pueden desconectar, pues la partida aun estara "esperando" algunas de sus acciones, pero no se cae el programa cuando este se desconecta. Por último, la caida inesperada del servidor no se manejar de manera correcta, solamente esta el caso de que si un cliente se conecta, y el servidor esta "caido", se muestra en consola que el servidor no esta disponible manejando el error de conexion.
*  :white_check_mark: Arquitectura Cliente Servidor <sub>2</sub>: Hecha completa, los roles están claramente separados, de hecho, ninguna de las clases logicas del juego (Por ejemplo ``Mapa``, ``Usuario`` , ``Banco``, entre otras) no estan contenidas en el programa de cliente, todo se envia al servidor, y este maneja todos los datos a nivel logico en las diferentes clases del juego. Luego de procesada la información se envía solo lo necesario para actualizar la interfas de el/Los clientes según corresponda, esto se hace usando los metodos de la interfaz de networking ``send_command`` y ``send_command_to_all`` que envian comandos a uno o varios clientes respectivamente. Un buen ejemplo es cuando se tiran los dados, donde el cliente notifica al servidor que apretó el botón, los dados se tiran a nivel lógico en la clase ``Juego``, ``lanzar_dados`` del archivo ``juego.py``, y estos numeros de dados son enviados a las interfaces de todos los clientes usando la linea ``interfaz_network.send_command_to_all("update_dices", dado_1, dado_2)``, es decir solo se envian los numeros que se deben mostrar en la interfaz al backend del cliente, que posteriormente envia una senal al frontend del cliente para actualizar los dados, (Es una especie de burocracia, pero mantiene los Roles bien separados).
	* :white_check_mark: Roles<sub>2.1</sub> : A nivel específico de roles, el servidor contiene toda la logica del juego, en todos los archivos que estan contenidos en la carpeta ``juego``, lo que incluye generación del mapa, robo de cartas, lanzamiento de dados, validación de costos de compras, validación de construcciones en el mapa, entre muchas otras cosas. Mientras que por otro lado, el cliente solo tiene funcionamiento lógico/gráfico (Osea lo que no es networking) como backend  en la carpeta ``backend`` y frontend en la carpeta ``frontend``, los cuales se encargan en primer lugar de habilitar o bloquear los widgets de Input del usuario según se lo envie el servidor (pues este maneja los turnos), en segundo lugar, de actualizar la información que se muestra en la interfaz del jugador según, los datos que valla enviando el servidor (Ejemplo claro de ello son cuando se cargan las materias primas y los numeros de fichas en la interfaz, según los datos que manda el servidor cuando carga el mapa). Además como ejemplo de validación se tiene cuando se compran casas o cartas de desarrollo, donde a través del ``Banco`` se validan y notifican las compras, y a través del ``Mapa`` se validan las adyacencias de construcciones. Por último, en la parte de "Almacenar y actualizar", se hicieron propertys para todas las clases del juego, cosa que cada vez que alguien gane un punto, construya algo, gane materias primas, entre otras cosas, esta información se envia a todos los usuarios para que se actulizen sus interfaces usando el networking del servidor.
	* :white_check_mark: Consistencia<sub>2.2</sub> : Se puede ver con el funcionamiento que todo se va actualizando, y para uso de locks, como se ha mencionado varias veces, como a nivel de networking todos usan la misma ``InterfazNet``, todos usan los mismos locks para acceder al networking, especificamente se implementaron locks en esta clase para:
		* 1) Enviar Comandos a los clientes
		* 2) Sacar comandos de la cola de comandos del servidor para su posterior ejecucion (Estructura FIFO)
	* :white_check_mark: Logs<sub>2.3</sub>: Se implementaron los logs según lo que indicaba el enunciado, donde se muestra un log cada vez que se añade un comando, y cada vez que se realiza, además de todas las cosas pedidas en el enunciado (Mis logs muestran practicamente todo lo que pasa en el programa :smile: y como se van comunicando y ejecutando las cosas), y además se usa un lock para imprimir logs para que estos no se "solapen" al imprimirse en la consola.

* :white_check_mark: Manejo de Bytes :zero::one::zero::one::one:<sub>3</sub> : Hecha Completa
	* :white_check_mark: Codificación 🐶➡️🈹<sub>3.1</sub> : La codificación está implementada tanto en cliente como en servidor en el archivo ``networking`` en la clase ``Server/ClientNet``, especificamente en el método ``send_bytes`` el cual recibe bytes, y aplica el protocolo de codificación dado en el enunciado, además la serialización misma de los objetos se hace en los métodos ``send_comand`` y ``send_commando_to_all`` los cuales serializan com pickle los comandos que luego se envian a los clientes/servidor según corresponda, siguiendo la logica:
	send_command -> Bytes -> send_bytes -> BytesCodificadosConElProtocolo -> se envian los bytes
	* :white_check_mark: Decodificación 🈹➡️🐶<sub>3.2</sub> : La decodificación se encuentra en la clase ``Server/ClientNet`` en el archivo ``networking.py``, específicamente en el metodo ``recive_data`` el cual se encarga de decodificar los bytes enviados con el protocolo del enunciado, y retorna los bytes originales, que luego son deserializados según corresponde usando pickle, en el ``thread_de_escucha_cliente/servidor``, decodificando el comando mandado.
	* :white_check_mark: Integración<sub>3.3</sub>: Como se dijo antes, tanto en el envió como decodificación se integra el protocolo de envio de mensajes (Que en mi caso estos mensajes siempre son los comandos que se explicaron mas arriba).

* :white_check_mark: :x: Interfaz Grafica<sub>4</sub>: 
	*  :white_check_mark: Modelación <sub>4.1</sub>:  Se hizo una separacion frontend/backend de la interfaz del cliente, donde el frontend solo instancia y actualiza los widgets de la interfaz, y le envia al backend las acciones realizadas en la interfaz, mientras que es el backend el que maneja todos los comandos que llegan al networking del cliente, y envia señales para que se actualizen todos los elementos de la interfaz, asi como también recibe senales del frontend con los widgets de inputs usados, y envia los comandos respectivos al servidor para que este responda y el DCColonos funcione.
	*  :white_check_mark: Sala de Espera<sub>4.2</sub>:  Se actualiza correctamente, y  no deja entrar al servidor en el caso de que ya este lleno, mostrandose un mensaje acorde.
	*  :white_check_mark::x: Sala Juego<sub>4.3</sub>: Se implementa todo lo pedido, excepto que no se pueden comprar caminos, y el botón de sala de espera no redirige a la sala de espera porque no tiene sentido, puesto que no se pueden jugar dos partidas seguidas sin volver a correr el servidor y los clientes.
	*  :white_check_mark: Fin de la partida<sub>4.4</sub>:  Al llegarse a los puntos necesarios para ganar se finaliza la partida y se muestra una ventana que muestra los resultados, notificando si ganó o perdió , y mostrando todos los puntajes de forma ordenada.

* :white_check_mark: :x: Grafo <sub>5</sub>:  El funcionamiento del grafo se encuentra en el servidor en la carpeta ``juego\mapa``, donde se encuentran los archivos ``grafo.json`` y el archivo ``mapa.py``, este útlimo contiene las clases ``Nodo`` que representa los vertices del grafo, la clase ``Hexagono`` que modela los hexagonos y la clase ``Conexion`` que representa las aristas del grafo y los caminos del juego. Todas estas se llaman en la clase ``Mapa``la cual modela todo el mapa del juego.
	*  :white_check_mark: Archivo <sub>5.1</sub> : En el metodo ``cargar_mapa`` de clase mapa se carga el archivo ``grafo.json`` y se instancia todo el mapa, junto con los nodos, hexagonos, numeros de fichas, etc...
	* :white_check_mark: Modelacion <sub>5.2</sub> : Se usan propertys para actualizar todos los datos cuando se carga el mapa, enviando la informacion a todos los usuarios jugando.
	* :white_check_mark: :x: Funcionalidades <sub>5.3</sub> : Si se verifica que se cumplan las restricciones para construir una choza, pero solamente que no haya una choza en un nodo adyacente, porque como se dijo al principio, no se implementaron los caminos. Además, aunque si se puede añadir un camino al mapa a nivel lógico, como no estás implementados, no se muestran en la interfaz. y no se revisan las restricciones de construcción de estos, por último, se encuentra en la clase un método ``carretera_mas_larga`` que calcula el camino mas largo segun los caminos puestos en el mapa usando backtracking, incluso en el ``if __name__ == __main__``de el archivo mapa se muestra un ejemplo instanciando algunos caminos, y el algoritmo funciona, solo que no filtra que sean de un mismo usuario, y como se dijo, no está implementado a nivel gráfico, pero para probar dicho main deben comentarse las lineas de envio de comandos entre otras cosas, pero en el fondo el algoritmo lo que hace es ir avanzando de nodo en nodo contando caminos construidos hasta llegar a un camino que no puede seguir, luego vuelve hacia atras descontando los caminos, hasta que llega a un nodo que aun tenia caminos por recorrer, recorriendo asi todos los caminos que conectan los nodos, una vez que todos fueron visitados, el algoritmo se devuelve hasta el nodo inicial, finalizando el algoritmo y devolviendo los largos de los caminos desde el nodo inicial, iterando sobre todos los nodos y sacando el máximo, se encuentra efectivamente la carretera mas larga.

* :white_check_mark: :x: Reglas DCColonos <sub>6</sub> : Se cumplen todas las reglas, pero no las que involucran caminos, puesto que estos no se implementan.
	* :white_check_mark: :x: Inicio Juego <sub>6.1</sub> : Hecho completo pero sin caminos.
	*  :white_check_mark: lanzamiento de Dados <sub>6.2</sub> : Hecho completo incluido con el 7 el cual bota materias primas aleatorias y lo notifica a los jugadores, los dados se actualizan en todas las interfaces y se reparten las materias primas
	* :white_check_mark: :x: Turno <sub>6.3</sub> : Se hace todo menos la carretera mas larga, la implementación del punto de victoria se encuentra en el servidor en ``juego\juego.py`` donde se llama a la funcion ``comprar_carta_desarrollo`` cuando el jugador de turno apreta el boton de carta de desarrollo, este le envia al banco la acción para validar la compra y el banco de la clase ``Banco`` en el archivo ``banco.py`` de la carpeta ``entidades`` en el metodo ``comprar_carta_desarrollo`` valida el precio y usa el archivo entregado en el enunciado para sacar una carta de desarrollo, y instanciar la carta pedida, esta instancia de carta la retorna al juego quien la activa inmediatamente y muestra un ``Qdialog`` en la interfaz para notificar o realizar la acción que ocurre (Ya sea punto de victoria o Monopolio), esta acción además se notifica a todos los jugadores. 
	* :white_check_mark: Termino del juego<sub>6.4</sub> : Hecho completo
* :white_check_mark: General <sub>7</sub> : Hecho completo
	* :white_check_mark: Parametros <sub>7.1</sub> : Se tiene un  archivo de parametros para cada programa (Cliente y Servidor) y se llaman usando json cuando se necesitan.
	* :white_check_mark: Grafo <sub>7.2</sub> : Se utiliza y carga en el metodo ``cargar_mapa`` ya mencionado de la clase ``Mapa``
	* :white_check_mark: Generador de mazos <sub>7.3</sub> : Se usa el metodo ``sacar_cartas`` en la clase ``Banco`` cuando se quiere comprar una carta de desarrollo como se explicó antes.
* :white_check_mark: Bonus <sub>8</sub> : Se implementa el bonus de ladron (Que tiene la cara del profe 👺) y tambíen se implementa la ventana de chat.
## Ejecución :computer:
Los modulos principales de la tarea son los archivos ``main.py `` del servidor que se debe correr en primer lugar, y el archivo ``main.py`` del cliente que se deben correr (para abrir varios clientes) después de correr el main del servidor. Además se deben poner archivos en las carpetas especificadas como se indica a continuacion:
1.  Carpeta ```sprites``` dentro de ```T03\client``` que deben ser los mismos sprites que se subieron en el syllabus.
2. Archivo ``ladron.png`` y ``exchange_icon.png`` que se subieron en la carpeta raiz se deben ubicar en la carpeta sprites del cliente antes mencionada.
3. Archivo ``grafo.json`` dentro de ``T03\server\juego\mapa`` que corresponde al archivo pasado en el syllabus.
4. Archivo ``generador_de_cartas.py`` dentro de ``T03\server\juego\entidades`` que corresponde al archivo pasado en el syllabus.

## Librerías :books:
### Librerías externas utilizadas
Las librerías externas utilizadas fueron ``PyQt5``, y ``Faker`` y por tanto deben estar instaladas para que corra el programa, el resto fueron librerias built-in como:

1. ```random```
2. ``collections``
3. ``threading``
4. ``socket``
5. ``sys``
6. ``time``

### Librerías propias
Por otro lado, los módulos que fueron creados fueron los siguientes:

Por el lado del servidor
* ``comando.py``: Contiene ``Comando`` el cual modela un comando para enviar entre cliente y servidor.
* ``networking``: Contiene ``ServerNet`` el cual modela el networking del servidor con serializacion, protocolo de envio, manejo de comandos etc. y contiene ``InterfazServerNet`` que modela un objeto de acceso al ServerNet y luego se instancia en el mismo archivo para ser compartido en todas partes la misma instancia y acceder al networking sin problemas de concurrencia.
* Carpeta ``juego\``
	* ``mapa\``
		1. ```mapa.py```: contiene ``Nodo``, ``Conexion``, ``Hexagono`` y ``Mapa`` que se encarga de la modelación del grafo del mapa y los atributos para el juego.
	* ``items\``
		1) ``carta_desarrollo.py``: Contiene ``CartaDesarrollo``, ``CartaPuntoVictoria``, ``CartaMonopolio`` que modelan las distintas cartas de dasarrollo.
		2) ``construcciones.py``: Contiene ``Choza``, ``Ciudad``, ``Camino`` que modelan las construcciones del juego.
		3) ``mazo.py``: Contiene ``Mazo`` que es un diccionario personalizado que modela los mazos de los jugadores.
	* ``entidades\``
		1) ``usuario.py``: Contiene ``Usuario``que modela a un usuario que esta jugando en la partida con sus puntos su mazo, sus puntos de victoria, etc...
		2) ``banco.py``: Contiene ``Banco`` que modela el banco, quien valida las compras de construcciones revisando materias primas de los mazos del jugador y usa el modulo entregado para robar cartas de desarrollo.
## Supuestos y consideraciones adicionales :thinking:
Los supuestos que realicé durante la tarea son los siguientes:

1. Los jugadores una vez entrados a la partida no se iran AFK, pues el servidor no podría saber que acciones se ivan a realizar (Este supuesto está mal tomado porque en el fondo no implementé una desconexión de un cliente "in game").
2. El jugador será capáz de reconocer los elementos de la interfaz, ya sea boton de carta de desarrollo, ficha de ladrón (El profe), boton de intercambio, etc.
3. Se pondrán el host y port en los parametros de manera que funcione de forma correcta el cliente y el servidor.
4. Para volver a jugar se correran denuevo el servidor, y los clientes que se van a conectar.
5. La interfaz creada siempre cabrá en la pantalla donde se va a jugar.

## Referencias de código externo :book:

No usé codigo externo en esta tarea, solo lei documentación de Pyqt5, Faker, y saqué ideas de la materia de clases, pero sin copiar código.